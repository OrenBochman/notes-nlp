{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "date: 2020-11-19\n",
        "title: 'Creating a Siamese model using Trax: Ungraded Lecture Notebook'\n",
        "subtitle: \"Sequence Models\"\n",
        "#description: \"we cover Neural networks for deep learning, then build a tweet classifier that places tweets into positive or negative sentiment categories, using a DNN.\"\n",
        "categories: \n",
        "  - NLP \n",
        "  - Coursera \n",
        "  - Lab\n",
        "  - Sequence Models\n",
        "jupyter: python3\n",
        "---\n",
        "\n",
        "\n",
        "![course banner](/images/Course-Logo-3-3.webp){.column-margin .nolightbox} \n"
      ],
      "id": "e983924a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import trax\n",
        "from trax import layers as tl\n",
        "import trax.fastmath.numpy as np\n",
        "import numpy\n",
        "\n",
        "# Setting random seeds\n",
        "# set random seeds to make this notebook easier to replicate\n",
        "from trax import fastmath\n",
        "seed=10\n",
        "rng = fastmath.random.get_prng(seed)\n",
        "#trax.supervised.trainer_lib.init_random_number_generators(10)\n",
        "numpy.random.seed(seed)"
      ],
      "id": "19763ae6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## L2 Normalization\n",
        "\n",
        "Before building the model you will need to define a function that applies L2 normalization to a tensor. This is very important because in this week's assignment you will create a custom loss function which expects the tensors it receives to be normalized. Luckily this is pretty straightforward:\n"
      ],
      "id": "7baf9d65"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def normalize(x):\n",
        "    return x / np.sqrt(np.sum(x * x, axis=-1, keepdims=True))"
      ],
      "id": "a6add745",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Notice that the denominator can be replaced by `np.linalg.norm(x, axis=-1, keepdims=True)` to achieve the same results and that Trax's numpy is being used within the function.\n"
      ],
      "id": "3cf04a89"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "tensor = numpy.random.random((2,5))\n",
        "print(f'The tensor is of type: {type(tensor)}\\n\\nAnd looks like this:\\n\\n {tensor}')"
      ],
      "id": "5dc336d4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "norm_tensor = normalize(tensor)\n",
        "print(f'The normalized tensor is of type: {type(norm_tensor)}\\n\\nAnd looks like this:\\n\\n {norm_tensor}')"
      ],
      "id": "b21230a2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Notice that the initial tensor was converted from a numpy array to a jax array in the process.\n",
        "\n",
        "## Siamese Model\n",
        "\n",
        "To create a `Siamese` model you will first need to create a LSTM model using the `Serial` combinator layer and then use another combinator layer called `Parallel` to create the Siamese model. You should be familiar with the following layers (notice each layer can be clicked to go to the docs):\n",
        "   - [`Serial`](https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.combinators.Serial) A combinator layer that allows to stack layers serially using function composition.\n",
        "   - [`Embedding`](https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.core.Embedding) Maps discrete tokens to vectors. It will have shape `(vocabulary length X dimension of output vectors)`. The dimension of output vectors (also called `d_feature`) is the number of elements in the word embedding.\n",
        "   - [`LSTM`](https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.rnn.LSTM) The LSTM layer. It leverages another Trax layer called [`LSTMCell`](https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.rnn.LSTMCell). The number of units should be specified and should match the number of elements in the word embedding.\n",
        "   - [`Mean`](https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.core.Mean) Computes the mean across a desired axis. Mean uses one tensor axis to form groups of values and replaces each group with the mean value of that group.\n",
        "   - [`Fn`](https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.base.Fn) Layer with no weights that applies the function f, which should be specified using a lambda syntax. \n",
        "   - [`Parallel`](https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.combinators.Parallel) It is a combinator layer (like `Serial`) that applies a list of layers in parallel to its inputs.\n",
        "\n",
        "Putting everything together the Siamese model will look like this:\n"
      ],
      "id": "422d85c0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "vocab_size = 500\n",
        "model_dimension = 128\n",
        "\n",
        "# Define the LSTM model\n",
        "LSTM = tl.Serial(\n",
        "        tl.Embedding(vocab_size=vocab_size, d_feature=model_dimension),\n",
        "        tl.LSTM(model_dimension),\n",
        "        tl.Mean(axis=1),\n",
        "        tl.Fn('Normalize', lambda x: normalize(x))\n",
        "    )\n",
        "\n",
        "# Use the Parallel combinator to create a Siamese model out of the LSTM \n",
        "Siamese = tl.Parallel(LSTM, LSTM)"
      ],
      "id": "761d68ab",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next is a helper function that prints information for every layer (sublayer within `Serial`):\n"
      ],
      "id": "9e8fef33"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def show_layers(model, layer_prefix):\n",
        "    print(f\"Total layers: {len(model.sublayers)}\\n\")\n",
        "    for i in range(len(model.sublayers)):\n",
        "        print('========')\n",
        "        print(f'{layer_prefix}_{i}: {model.sublayers[i]}\\n')\n",
        "\n",
        "print('Siamese model:\\n')\n",
        "show_layers(Siamese, 'Parallel.sublayers')\n",
        "\n",
        "print('Detail of LSTM models:\\n')\n",
        "show_layers(LSTM, 'Serial.sublayers')"
      ],
      "id": "365dfcf2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Try changing the parameters defined before the Siamese model and see how it changes!\n",
        "\n",
        "You will actually train this model in this week's assignment. For now you should be more familiarized with creating Siamese models using Trax. \n",
        "\n",
        "**Keep it up!**\n"
      ],
      "id": "cf26ba7b"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/oren/.local/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}