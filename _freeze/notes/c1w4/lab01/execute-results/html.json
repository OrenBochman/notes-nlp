{
  "hash": "a389fe98cdbb5281bb1541b79441d5a6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ndate: 2020-10-12\ntitle: Vector manipulation in Python\njupyter: python3\ncategories: \n  - NLP \n  - Coursera \n  - Lab\n  - Word Embeddings\n  - Translation task\n  - Search Task\n---\n\n\n\n![course banner](/images/Course-Logo-1-3.webp){#fig-00 .column-margin .nolightbox}\n\nIn this lab, we will have the opportunity to practice once again with the NumPy library. This time, we will explore some advanced operations with arrays and matrices.\n\nAt the end of the previous module, we used PCA to transform a set of many variables into a set of only two uncorrelated variables. This process was made through a transformation of the data called rotation. \n\nIn this week's assignment, we will need to find a transformation matrix from English to French vector space embeddings. Such a transformation matrix is nothing else but a matrix that rotates and scales vector spaces.\n\nIn this notebook, we will explain in detail the rotation transformation. \n\n\n## Transforming vectors\n\nThere are three main vector transformations:\n* Scaling\n* Translation\n* Rotation\n\nIn previous notebooks, we have applied the first two kinds of transformations. Now, let us learn how to use a fundamental transformation on vectors called _rotation_.\n\nThe rotation operation changes the direction of a vector, letting unaffected its dimensionality and its norm. Let us explain with some examples. \n\nIn the following cells, we will define a NumPy matrix and a NumPy array. Soon we will explain how this is related to matrix rotation.\n\n::: {#add1dd60 .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np                     # Import numpy for array manipulation\nimport matplotlib.pyplot as plt        # Import matplotlib for charts\nfrom utils_nb import plot_vectors      # Function to plot vectors (arrows)\n```\n:::\n\n\n### Example 1\n\n::: {#fae2d3e8 .cell execution_count=3}\n``` {.python .cell-code}\n# Create a 2 x 2 matrix\nR = np.array([[2, 0],\n              [0, -2]])\n```\n:::\n\n\n::: {#a4973243 .cell execution_count=4}\n``` {.python .cell-code}\nx = np.array([[1, 1]]) # Create a 1 x 2 matrix\n```\n:::\n\n\nThe dot product between a vector and a square matrix produces a rotation and a scaling of the original vector. \n\nRemember that our recommended way to get the dot product in Python is np.dot(a, b):\n\n::: {#bfc1779e .cell execution_count=5}\n``` {.python .cell-code}\ny = np.dot(x, R) # Apply the dot product between x and R\ny\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\narray([[ 2, -2]])\n```\n:::\n:::\n\n\nWe are going to use Pyplot to inspect the effect of the rotation on 2D vectors visually. For that, we have created a function `plot_vectors()` that takes care of all the intricate parts of the visual formatting. The code for this function is inside the `utils_nb.py` file. \n\nNow we can plot the vector $\\vec x = [1, 1]$ in a cartesian plane. The cartesian plane will be centered at `[0,0]` and its x and y limits will be between `[-4, +4]`\n\n::: {#57d0e72d .cell execution_count=6}\n``` {.python .cell-code}\nplot_vectors([x], axes=[4, 4], fname='transform_x.svg')\n```\n\n::: {.cell-output .cell-output-display}\n![](lab01_files/figure-html/cell-6-output-1.png){width=573 height=416}\n:::\n:::\n\n\nNow, let's plot in the same system our vector $\\vec x = [1, 1]$ and its dot product with the matrix\n\n$$Ro = \\begin{bmatrix} 2 & 0 \\\\ 0 & -2 \\end{bmatrix}$$\n\n$$y = x \\cdot Ro = [[-2, 2]]$$\n\n::: {#4fca6218 .cell execution_count=7}\n``` {.python .cell-code}\nplot_vectors([x, y], axes=[4, 4], fname='transformx_and_y.svg')\n```\n\n::: {.cell-output .cell-output-display}\n![](lab01_files/figure-html/cell-7-output-1.png){width=573 height=416}\n:::\n:::\n\n\nNote that the output vector `y` (blue) is transformed in another vector. \n\n### Example 2\n\nWe are going to use Pyplot to inspect the effect of the rotation on 2D vectors visually. For that, we have created a function that takes care of all the intricate parts of the visual formatting. The following procedure plots an arrow within a Pyplot canvas.\n\nData that is composed of 2 real attributes is telling to belong to a $ RxR $ or $ R^2 $ space. Rotation matrices in $R^2$ rotate a given vector $\\vec x$ by a counterclockwise angle $\\theta$ in a fixed coordinate system. Rotation matrices are of the form:\n\n$$Ro = \\begin{bmatrix} cos \\theta & -sin \\theta \\\\ sin \\theta & cos \\theta \\end{bmatrix}$$\n\nThe trigonometric functions in Numpy require the angle in radians, not in degrees. In the next cell, we define a rotation matrix that rotates vectors by $45^o$.\n\n::: {#ef3784a1 .cell execution_count=8}\n``` {.python .cell-code}\nangle = 100 * (np.pi / 180) #convert degrees to radians\n\nRo = np.array([[np.cos(angle), -np.sin(angle)],\n              [np.sin(angle), np.cos(angle)]])\n\nx2 = np.array([2, 2]).reshape(1, -1) # make it a row vector\ny2 = np.dot(x2, Ro)\n\nprint('Rotation matrix')\nprint(Ro)\nprint('\\nRotated vector')\nprint(y2)\n\nprint('\\n x2 norm', np.linalg.norm(x2))\nprint('\\n y2 norm', np.linalg.norm(y2))\nprint('\\n Rotation matrix norm', np.linalg.norm(Ro))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRotation matrix\n[[-0.17364818 -0.98480775]\n [ 0.98480775 -0.17364818]]\n\nRotated vector\n[[ 1.62231915 -2.31691186]]\n\n x2 norm 2.8284271247461903\n\n y2 norm 2.82842712474619\n\n Rotation matrix norm 1.414213562373095\n```\n:::\n:::\n\n\n::: {#c779c625 .cell execution_count=9}\n``` {.python .cell-code}\nplot_vectors([x2, y2], fname='transform_02.svg')\n```\n\n::: {.cell-output .cell-output-display}\n![](lab01_files/figure-html/cell-9-output-1.png){width=573 height=411}\n:::\n:::\n\n\nSome points to note:\n\n* The norm of the input vector is the same as the norm of the output vector. Rotations matrices do not modify the norm of the vector, only its direction.\n* The norm of any $R^2$ rotation matrix is always $\\sqrt 2 = 1.414221$\n\n## Frobenius Norm\n\nThe Frobenius norm is the generalization to $R^2$ of the already known norm function for vectors \n\n$$\\| \\vec a \\| = \\sqrt {{\\vec a} \\cdot {\\vec a}} $$\n\nFor a given $R^2$ matrix A, the frobenius norm is defined as:\n\n$$\\|\\mathrm{A}\\|_{F} \\equiv \\sqrt{\\sum_{i=1}^{m} \\sum_{j=1}^{n}\\left|a_{i j}\\right|^{2}}$$\n\n::: {#3eb74f7d .cell execution_count=10}\n``` {.python .cell-code}\nA = np.array([[2, 2],\n              [2, 2]])\n```\n:::\n\n\n`np.square()` is a way to square each element of a matrix. It must be equivalent to use the * operator in Numpy arrays.\n\n::: {#69d98c6d .cell execution_count=11}\n``` {.python .cell-code}\nA_squared = np.square(A)\nA_squared\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\narray([[4, 4],\n       [4, 4]])\n```\n:::\n:::\n\n\nNow we can sum over the elements of the resulting array, and then get the square root of the sum.\n\n::: {#5d1c5d69 .cell execution_count=12}\n``` {.python .cell-code}\nA_Frobenius = np.sqrt(np.sum(A_squared))\nA_Frobenius\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nnp.float64(4.0)\n```\n:::\n:::\n\n\nThat was the extended version of the `np.linalg.norm()` function. We can check that it yields the same result.\n\n::: {#0184ce59 .cell execution_count=13}\n``` {.python .cell-code}\nprint('Frobenius norm of the Rotation matrix')\nprint(np.sqrt(np.sum(Ro * Ro)), '== ', np.linalg.norm(Ro))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFrobenius norm of the Rotation matrix\n1.414213562373095 ==  1.414213562373095\n```\n:::\n:::\n\n\n**Congratulations!! We've covered a few more matrix operations in this lab. This will come in handy in this week's programming assignment!**\n\n",
    "supporting": [
      "lab01_files"
    ],
    "filters": [],
    "includes": {}
  }
}