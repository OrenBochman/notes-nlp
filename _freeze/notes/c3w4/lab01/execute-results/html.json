{
  "hash": "2aabfdf05aba0c56833309f0b183a8a4",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ndate: 2020-11-19\ntitle: 'Creating a Siamese model using Trax: Ungraded Lecture Notebook'\nsubtitle: \"Sequence Models\"\n#description: \"we cover Neural networks for deep learning, then build a tweet classifier that places tweets into positive or negative sentiment categories, using a DNN.\"\ncategories: \n  - NLP \n  - Coursera \n  - Lab\n  - Sequence Models\njupyter: python3\n---\n\n\n\n\n![course banner](/images/Course-Logo-3-3.webp){.column-margin .nolightbox} \n\n::: {#352f513d .cell execution_count=1}\n``` {.python .cell-code}\nimport trax\nfrom trax import layers as tl\nimport trax.fastmath.numpy as np\nimport numpy\n\n# Setting random seeds\n# set random seeds to make this notebook easier to replicate\nfrom trax import fastmath\nseed=10\nrng = fastmath.random.get_prng(seed)\n#trax.supervised.trainer_lib.init_random_number_generators(10)\nnumpy.random.seed(seed)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n2025-02-10 16:56:47.210910: E external/local_xla/xla/stream_executor/cuda/cuda_fft.cc:477] Unable to register cuFFT factory: Attempting to register factory for plugin cuFFT when one has already been registered\nWARNING: All log messages before absl::InitializeLog() is called are written to STDERR\nE0000 00:00:1739199407.224698  124526 cuda_dnn.cc:8310] Unable to register cuDNN factory: Attempting to register factory for plugin cuDNN when one has already been registered\nE0000 00:00:1739199407.228897  124526 cuda_blas.cc:1418] Unable to register cuBLAS factory: Attempting to register factory for plugin cuBLAS when one has already been registered\n```\n:::\n:::\n\n\n## L2 Normalization\n\nBefore building the model you will need to define a function that applies L2 normalization to a tensor. This is very important because in this week's assignment you will create a custom loss function which expects the tensors it receives to be normalized. Luckily this is pretty straightforward:\n\n::: {#155933ac .cell execution_count=2}\n``` {.python .cell-code}\ndef normalize(x):\n    return x / np.sqrt(np.sum(x * x, axis=-1, keepdims=True))\n```\n:::\n\n\nNotice that the denominator can be replaced by `np.linalg.norm(x, axis=-1, keepdims=True)` to achieve the same results and that Trax's numpy is being used within the function.\n\n::: {#67b2c768 .cell execution_count=3}\n``` {.python .cell-code}\ntensor = numpy.random.random((2,5))\nprint(f'The tensor is of type: {type(tensor)}\\n\\nAnd looks like this:\\n\\n {tensor}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe tensor is of type: <class 'numpy.ndarray'>\n\nAnd looks like this:\n\n [[0.77132064 0.02075195 0.63364823 0.74880388 0.49850701]\n [0.22479665 0.19806286 0.76053071 0.16911084 0.08833981]]\n```\n:::\n:::\n\n\n::: {#050f31fb .cell execution_count=4}\n``` {.python .cell-code}\nnorm_tensor = normalize(tensor)\nprint(f'The normalized tensor is of type: {type(norm_tensor)}\\n\\nAnd looks like this:\\n\\n {norm_tensor}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe normalized tensor is of type: <class 'jaxlib.xla_extension.ArrayImpl'>\n\nAnd looks like this:\n\n [[0.5739379  0.01544148 0.4714962  0.5571832  0.37093794]\n [0.26781026 0.23596111 0.9060541  0.20146926 0.10524315]]\n```\n:::\n:::\n\n\nNotice that the initial tensor was converted from a numpy array to a jax array in the process.\n\n## Siamese Model\n\nTo create a `Siamese` model you will first need to create a LSTM model using the `Serial` combinator layer and then use another combinator layer called `Parallel` to create the Siamese model. You should be familiar with the following layers (notice each layer can be clicked to go to the docs):\n   - [`Serial`](https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.combinators.Serial) A combinator layer that allows to stack layers serially using function composition.\n   - [`Embedding`](https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.core.Embedding) Maps discrete tokens to vectors. It will have shape `(vocabulary length X dimension of output vectors)`. The dimension of output vectors (also called `d_feature`) is the number of elements in the word embedding.\n   - [`LSTM`](https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.rnn.LSTM) The LSTM layer. It leverages another Trax layer called [`LSTMCell`](https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.rnn.LSTMCell). The number of units should be specified and should match the number of elements in the word embedding.\n   - [`Mean`](https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.core.Mean) Computes the mean across a desired axis. Mean uses one tensor axis to form groups of values and replaces each group with the mean value of that group.\n   - [`Fn`](https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.base.Fn) Layer with no weights that applies the function f, which should be specified using a lambda syntax. \n   - [`Parallel`](https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.combinators.Parallel) It is a combinator layer (like `Serial`) that applies a list of layers in parallel to its inputs.\n\nPutting everything together the Siamese model will look like this:\n\n::: {#42019cab .cell execution_count=5}\n``` {.python .cell-code}\nvocab_size = 500\nmodel_dimension = 128\n\n# Define the LSTM model\nLSTM = tl.Serial(\n        tl.Embedding(vocab_size=vocab_size, d_feature=model_dimension),\n        tl.LSTM(model_dimension),\n        tl.Mean(axis=1),\n        tl.Fn('Normalize', lambda x: normalize(x))\n    )\n\n# Use the Parallel combinator to create a Siamese model out of the LSTM \nSiamese = tl.Parallel(LSTM, LSTM)\n```\n:::\n\n\nNext is a helper function that prints information for every layer (sublayer within `Serial`):\n\n::: {#c6f37ad8 .cell execution_count=6}\n``` {.python .cell-code}\ndef show_layers(model, layer_prefix):\n    print(f\"Total layers: {len(model.sublayers)}\\n\")\n    for i in range(len(model.sublayers)):\n        print('========')\n        print(f'{layer_prefix}_{i}: {model.sublayers[i]}\\n')\n\nprint('Siamese model:\\n')\nshow_layers(Siamese, 'Parallel.sublayers')\n\nprint('Detail of LSTM models:\\n')\nshow_layers(LSTM, 'Serial.sublayers')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSiamese model:\n\nTotal layers: 2\n\n========\nParallel.sublayers_0: Serial[\n  Embedding_500_128\n  LSTM_128\n  Mean\n  Normalize\n]\n\n========\nParallel.sublayers_1: Serial[\n  Embedding_500_128\n  LSTM_128\n  Mean\n  Normalize\n]\n\nDetail of LSTM models:\n\nTotal layers: 4\n\n========\nSerial.sublayers_0: Embedding_500_128\n\n========\nSerial.sublayers_1: LSTM_128\n\n========\nSerial.sublayers_2: Mean\n\n========\nSerial.sublayers_3: Normalize\n\n```\n:::\n:::\n\n\nTry changing the parameters defined before the Siamese model and see how it changes!\n\nYou will actually train this model in this week's assignment. For now you should be more familiarized with creating Siamese models using Trax. \n\n**Keep it up!**\n\n",
    "supporting": [
      "lab01_files"
    ],
    "filters": [],
    "includes": {}
  }
}