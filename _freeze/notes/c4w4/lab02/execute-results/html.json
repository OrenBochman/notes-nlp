{
  "hash": "edf918e6327847f909b9e1907e434d66",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ndate: 2021-04-29\ntitle: 'Putting the \"Re\" in Reformer: Ungraded Lab'\njupyter: python3\nexecute: \n    error: true\n---\n\n\nThis ungraded lab will explore Reversible Residual Networks. You will use these networks in this week's assignment that utilizes the Reformer model. It is based on on the Transformer model you already know, but with two unique features.\n* Locality Sensitive Hashing (LSH) Attention to reduce the compute cost of the dot product attention and\n* Reversible Residual Networks (RevNets) organization to reduce the storage requirements when doing backpropagation in training.\n\nIn this ungraded lab we'll start with a quick review of Residual Networks and their implementation in Trax. Then we will discuss the Revnet architecture and its use in Reformer.\n\n## Outline\n- [Part 1:  Residual Networks](#1)\n    - [1.1  Branch](#1.1)\n    - [1.2  Residual Model](#1.2)\n- [Part 2:  Reversible Residual Networks](#2)\n    - [2.1  Trax Reversible Layers](#2.1)\n    - [2.2  Residual Model](#2.2)\n\n::: {#da34cee5 .cell execution_count=2}\n``` {.python .cell-code}\nimport trax\nfrom trax import layers as tl               # core building block\nimport numpy as np                          # regular ol' numpy\nfrom trax.models.reformer.reformer import (\n    ReversibleHalfResidualV2 as ReversibleHalfResidual,\n)                                           # unique spot\nfrom trax import fastmath                   # uses jax, offers numpy on steroids\nfrom trax import shapes                     # data signatures: dimensionality and type\nfrom trax.fastmath import numpy as jnp      # For use in defining new layer types.\nfrom trax.shapes import ShapeDtype\nfrom trax.shapes import signature\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n2025-02-10 16:54:01.601593: E external/local_xla/xla/stream_executor/cuda/cuda_fft.cc:477] Unable to register cuFFT factory: Attempting to register factory for plugin cuFFT when one has already been registered\nWARNING: All log messages before absl::InitializeLog() is called are written to STDERR\nE0000 00:00:1739199241.613582  121997 cuda_dnn.cc:8310] Unable to register cuDNN factory: Attempting to register factory for plugin cuDNN when one has already been registered\nE0000 00:00:1739199241.617462  121997 cuda_blas.cc:1418] Unable to register cuBLAS factory: Attempting to register factory for plugin cuBLAS when one has already been registered\n```\n:::\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">ImportError</span>                               Traceback (most recent call last)\nCell <span class=\"ansi-green-fg\">In[1], line 4</span>\n<span class=\"ansi-green-fg ansi-bold\">      2</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">from</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"font-weight:bold;color:rgb(0,0,255)\">trax</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"font-weight:bold;color:rgb(0,135,0)\">import</span> layers <span style=\"font-weight:bold;color:rgb(0,135,0)\">as</span> tl               <span style=\"font-style:italic;color:rgb(95,135,135)\"># core building block</span>\n<span class=\"ansi-green-fg ansi-bold\">      3</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">import</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"font-weight:bold;color:rgb(0,0,255)\">numpy</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"font-weight:bold;color:rgb(0,135,0)\">as</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"font-weight:bold;color:rgb(0,0,255)\">np</span>                          <span style=\"font-style:italic;color:rgb(95,135,135)\"># regular ol' numpy</span>\n<span class=\"ansi-green-fg\">----&gt; 4</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">from</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"font-weight:bold;color:rgb(0,0,255)\">trax</span><span style=\"font-weight:bold;color:rgb(0,0,255)\">.</span><span style=\"font-weight:bold;color:rgb(0,0,255)\">models</span><span style=\"font-weight:bold;color:rgb(0,0,255)\">.</span><span style=\"font-weight:bold;color:rgb(0,0,255)\">reformer</span><span style=\"font-weight:bold;color:rgb(0,0,255)\">.</span><span style=\"font-weight:bold;color:rgb(0,0,255)\">reformer</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"font-weight:bold;color:rgb(0,135,0)\">import</span> (\n<span class=\"ansi-green-fg ansi-bold\">      5</span>     ReversibleHalfResidualV2 <span style=\"font-weight:bold;color:rgb(0,135,0)\">as</span> ReversibleHalfResidual,\n<span class=\"ansi-green-fg ansi-bold\">      6</span> )                                           <span style=\"font-style:italic;color:rgb(95,135,135)\"># unique spot</span>\n<span class=\"ansi-green-fg ansi-bold\">      7</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">from</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"font-weight:bold;color:rgb(0,0,255)\">trax</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"font-weight:bold;color:rgb(0,135,0)\">import</span> fastmath                   <span style=\"font-style:italic;color:rgb(95,135,135)\"># uses jax, offers numpy on steroids</span>\n<span class=\"ansi-green-fg ansi-bold\">      8</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">from</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"font-weight:bold;color:rgb(0,0,255)\">trax</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"font-weight:bold;color:rgb(0,135,0)\">import</span> shapes                     <span style=\"font-style:italic;color:rgb(95,135,135)\"># data signatures: dimensionality and type</span>\n\n<span class=\"ansi-red-fg\">ImportError</span>: cannot import name 'ReversibleHalfResidualV2' from 'trax.models.reformer.reformer' (/home/oren/work/notes/notes-nlp/.venv/lib/python3.10/site-packages/trax/models/reformer/reformer.py)</pre>\n```\n:::\n\n:::\n:::\n\n\n\n## Part 1.0  Residual Networks {#1}\n\n[Deep Residual Networks ](https://arxiv.org/abs/1512.03385) (Resnets) were introduced to improve convergence in deep networks. Residual Networks introduce a shortcut connection around one or more layers in a deep network as shown in the diagram below from the original paper.\n\n\n![Residual Network diagram from original paper](img/Revnet7.PNG){#fig-01 width=\"250\" height=\"250\"}\n\nThe [Trax documentation](https://trax-ml.readthedocs.io/en/latest/notebooks/layers_intro.html#2.-Inputs-and-Outputs) describes an implementation of Resnets using `branch`. We'll explore that here by implementing a simple resnet built from simple function based layers. Specifically, we'll build a 4 layer network based on two functions, 'F' and 'G'.\n\n![4 stage Residual network](img/Revnet8.PNG){#fig-02 width=\"1400\" height=\"200\"}\n\nDon't worry about the lengthy equations. Those are simply there to be referenced later in the notebook.\n\n\n\n### Part 1.1  Branch {#1.1}\n \nTrax `branch` figures prominently in the residual network layer so we will first examine it. You can see from the figure above that we will need a function that will copy an input and send it down multiple paths. This is accomplished with a  [branch layer](https://trax-ml.readthedocs.io/en/latest/trax.layers.html#module-trax.layers.combinators), one of the Trax 'combinators'. Branch is a combinator that applies a list of layers in parallel to copies of inputs. Lets try it out!  First we will need some layers to play with. Let's build some from functions.\n\n::: {#27b97c7b .cell tags='[]' execution_count=3}\n``` {.python .cell-code}\n# simple function taking one input and one output\nbl_add1 = tl.Fn(\"add1\", lambda x0: (x0 + 1), n_out=1)\nbl_add2 = tl.Fn(\"add2\", lambda x0: (x0 + 2), n_out=1)\nbl_add3 = tl.Fn(\"add3\", lambda x0: (x0 + 3), n_out=1)\n# try them out\nx = np.array([1])\nprint(bl_add1(x), bl_add2(x), bl_add3(x))\n# some information about our new layers\nprint(\n    \"name:\",\n    bl_add1.name,\n    \"number of inputs:\",\n    bl_add1.n_in,\n    \"number of outputs:\",\n    bl_add1.n_out,\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2] [3] [4]\nname: add1 number of inputs: 1 number of outputs: 1\n```\n:::\n:::\n\n\n::: {#bd3d4338 .cell execution_count=4}\n``` {.python .cell-code}\nbl_3add1s = tl.Branch(bl_add1, bl_add2, bl_add3)\nbl_3add1s\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nBranch_out3[\n  add1\n  add2\n  add3\n]\n```\n:::\n:::\n\n\nTrax uses the concept of a 'stack' to transfer data between layers.\nFor Branch, for each of its layer arguments, it copies the `n_in` inputs from the stack and provides them to the layer, tracking the max_n_in, or the largest n_in required. It then pops the max_n_in elements from the stack.\n<img src = \"branch1.PNG\" height=\"260\" width=\"600\">\n<center><b>Figure 3: One in, one out Branch</b></center>\nOn output, each layer, in succession pushes its results onto the stack. Note that the push/pull operations impact the top of the stack. Elements that are not part of the operation (n, and m in the diagram) remain intact.\n\n::: {#6d8e400b .cell execution_count=5}\n``` {.python .cell-code}\n# n_in = 1, Each bl_addx pushes n_out = 1 elements onto the stack\nbl_3add1s(x)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n(array([2]), array([3]), array([4]))\n```\n:::\n:::\n\n\n::: {#7b580cb6 .cell execution_count=6}\n``` {.python .cell-code}\n# n = np.array([10]); m = np.array([20])  # n, m will remain on the stack\nn = \"n\"\nm = \"m\"  # n, m will remain on the stack\nbl_3add1s([x, n, m]) \n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n(array([2]), array([3]), array([4]), 'n', 'm')\n```\n:::\n:::\n\n\nEach layer in the input list copies as many inputs from the stack as it needs, and their outputs are successively combined on stack. Put another way, each element of the branch can have differing numbers of inputs and outputs. Let's try a more complex example.\n\n::: {#dc26777a .cell execution_count=7}\n``` {.python .cell-code}\nbl_addab = tl.Fn(\n    \"addab\", lambda x0, x1: (x0 + x1), n_out=1\n)  # Trax figures out how many inputs there are\nbl_rep3x = tl.Fn(\n    \"add2x\", lambda x0: (x0, x0, x0), n_out=3\n)  # but you have to tell it how many outputs there are\nbl_3ops = tl.Branch(bl_add1, bl_addab, bl_rep3x)\n```\n:::\n\n\nIn this case, the number if inputs being copied from the stack varies with the layer\n<img src = \"branch2.PNG\" height=\"260\" width=\"600\">\n<center><b>Figure 4: variable in, variable out Branch</b></center>\nThe stack when the operation is finished is 5 entries reflecting the total from each layer.\n\n::: {#c469d76c .cell execution_count=8}\n``` {.python .cell-code}\n# Before Running this cell, what is the output you are expecting?\ny = np.array([3])\nbl_3ops([x, y, n, m])\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n(array([2]), array([4]), array([1]), array([1]), array([1]), 'n', 'm')\n```\n:::\n:::\n\n\nBranch has a special feature to support Residual Network. If an argument is 'None', it will pull the top of stack  and push it (at its location in the sequence) onto the output stack\n<img src = \"branch3.PNG\" height=\"260\" width=\"600\">\n<center><b>Figure 5: Branch for Residual</b></center>\n\n::: {#6c3487df .cell tags='[]' execution_count=9}\n``` {.python .cell-code}\nbl_2ops = tl.Branch(bl_add1, None)\nbl_2ops([x, n, m])\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n(array([2]), array([1]), 'n', 'm')\n```\n:::\n:::\n\n\n<a name=\"1.2\"></a>\n### Part 1.2  Residual Model\nOK, your turn. Write a function 'MyResidual', that uses `tl.Branch` and `tl.Add` to build a residual layer. If you are curious about the Trax implementation, you can see the code [here](https://github.com/google/trax/blob/190ec6c3d941d8a9f30422f27ef0c95dc16d2ab1/trax/layers/combinators.py).\n\n::: {#118ac2e1 .cell execution_count=10}\n``` {.python .cell-code}\ndef MyResidual(layer):\n    return tl.Serial(\n        ### START CODE HERE ###\n        tl.Branch(layer, None),\n        tl.Add(),\n        ### END CODE HERE ###\n    )\n```\n:::\n\n\n::: {#01efb0db .cell execution_count=11}\n``` {.python .cell-code}\n# Lets Try it\nmr = MyResidual(bl_add1)\nx = np.array([1])\nmr([x, n, m])\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n(array([3]), 'n', 'm')\n```\n:::\n:::\n\n\n**Expected Result**\n(array([3]), 'n', 'm')\n\nGreat! Now, let's build the 4 layer residual Network in Figure 2. You can use `MyResidual`, or if you prefer, the tl.Residual in Trax, or a combination!\n\n::: {#ce4fc11c .cell execution_count=12}\n``` {.python .cell-code}\nFl = tl.Fn(\"F\", lambda x0: (2 * x0), n_out=1)\nGl = tl.Fn(\"G\", lambda x0: (10 * x0), n_out=1)\nx1 = np.array([1])\n```\n:::\n\n\n::: {#46f3e974 .cell execution_count=13}\n``` {.python .cell-code}\nresfg = tl.Serial(\n    ### START CODE HERE ###\n    # None,  #Fl    # x + F(x)\n    # None,  #Gl    # x + F(x) + G(x + F(x)) etc\n    # None,  #Fl\n    # None,  #Gl\n    ### END CODE HERE ###\n)\n```\n:::\n\n\n::: {#5680ccd7 .cell execution_count=14}\n``` {.python .cell-code}\n# Lets try it\nresfg([x1, n, m])\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n[array([1]), 'n', 'm']\n```\n:::\n:::\n\n\n**Expected Results**\n(array([1089]), 'n', 'm')\n\n<a name=\"2\"></a>\n## Part 2.0 Reversible Residual Networks\nThe Reformer utilized RevNets to reduce the storage requirements for performing backpropagation.\n<img src = \"Reversible2.PNG\" height=\"260\" width=\"600\">\n<center><b>Figure 6: Reversible Residual Networks </b></center>\nThe standard approach on the left above requires one to store the outputs of each stage for use during backprop. By using the organization to the right, one need only store the outputs of the last stage, y1, y2 in the diagram. Using those values and running the algorithm in reverse, one can reproduce the values required for backprop. This trades additional computation for memory space which is at a premium with the current generation of GPU's/TPU's.\n\nOne thing to note is that the forward functions produced by two networks are similar, but they are not equivalent. Note for example the asymmetry in the output equations after two stages of operation.\n<img src = \"Revnet1.PNG\" height=\"340\" width=\"1100\">\n<center><b>Figure 7: 'Normal' Residual network (Top) vs REversible Residual Network </b></center>\n\n### Part 2.1  Trax Reversible Layers\n\nLet's take a look at how this is used in the Reformer.\n\n::: {#63c19451 .cell execution_count=15}\n``` {.python .cell-code}\nrefm = trax.models.reformer.ReformerLM(\n    vocab_size=33000, n_layers=2, mode=\"train\"  # Add more options.\n)\nrefm\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nSerial[\n  Serial[\n    ShiftRight(1)\n  ]\n  Embedding_33000_512\n  Dropout\n  Serial[\n    PositionalEncoding\n  ]\n  Dup_out2\n  ReversibleSerial_in2_out2[\n    ReversibleHalfResidualDecoderAttn_in2_out2[\n      Serial[\n        LayerNorm\n      ]\n      SelfAttention\n    ]\n    ReversibleSwap_in2_out2\n    ReversibleHalfResidualDecoderFF_in2_out2[\n      Serial[\n        LayerNorm\n        Dense_2048\n        Dropout\n        Serial[\n          FastGelu\n        ]\n        Dense_512\n        Dropout\n      ]\n    ]\n    ReversibleSwap_in2_out2\n    ReversibleHalfResidualDecoderAttn_in2_out2[\n      Serial[\n        LayerNorm\n      ]\n      SelfAttention\n    ]\n    ReversibleSwap_in2_out2\n    ReversibleHalfResidualDecoderFF_in2_out2[\n      Serial[\n        LayerNorm\n        Dense_2048\n        Dropout\n        Serial[\n          FastGelu\n        ]\n        Dense_512\n        Dropout\n      ]\n    ]\n    ReversibleSwap_in2_out2\n  ]\n  Concatenate_in2\n  LayerNorm\n  Dropout\n  Serial[\n    Dense_33000\n  ]\n]\n```\n:::\n:::\n\n\nEliminating some of the detail, we can see the structure of the network.\n<img src = \"Revnet2.PNG\" height=\"300\" width=\"350\">\n<center><b>Figure 8: Key Structure of Reformer Reversible Network Layers in Trax </b></center>\n\nWe'll review the Trax layers used to implement the Reversible section of the Reformer. First we can note that not all of the reformer is reversible. Only the section in the ReversibleSerial layer is reversible. In a large Reformer model, that section is repeated many times making up the majority of the model.\n<img src = \"Revnet3.PNG\" height=\"650\" width=\"1600\">\n<center><b>Figure 9: Functional Diagram of Trax elements in Reformer </b></center>\n\nThe implementation starts by duplicating the input to allow the two paths that are part of the reversible residual organization with [Dup](https://github.com/google/trax/blob/190ec6c3d941d8a9f30422f27ef0c95dc16d2ab1/trax/layers/combinators.py#L666). Note that this is accomplished by copying the top of stack and pushing two copies of it onto the stack. This then feeds into the ReversibleHalfResidual layer which we'll review in more detail below. This is followed by [ReversibleSwap](https://github.com/google/trax/blob/190ec6c3d941d8a9f30422f27ef0c95dc16d2ab1/trax/layers/reversible.py#L83). As the name implies, this performs a swap, in this case, the two topmost entries in the stack. This pattern is repeated until we reach the end of the ReversibleSerial section. At that point, the topmost 2 entries of the stack represent the two paths through the network. These are concatenated and pushed onto the stack. The result is an entry that is twice the size of the non-reversible version.\n\nLet's look more closely at the [ReversibleHalfResidual](https://github.com/google/trax/blob/190ec6c3d941d8a9f30422f27ef0c95dc16d2ab1/trax/layers/reversible.py#L154). This layer is responsible for executing the layer or layers provided as arguments and adding the output of those layers, the 'residual', to the top of the stack. Below is the 'forward' routine which implements this.\n<img src = \"Revnet4.PNG\" height=\"650\" width=\"1600\">\n<center><b>Figure 10: ReversibleHalfResidual code and diagram </b></center>\n\nUnlike the previous residual function, the value that is added is from the second path rather than the input to the set of sublayers in this layer. Note that the Layers called by the ReversibleHalfResidual forward function are not modified to support reverse functionality. This layer provides them a 'normal' view of the stack and takes care of reverse operation.\n\nLet's try out some of these layers! We'll start with the ones that just operate on the stack, Dup() and Swap().\n\n::: {#326c0808 .cell execution_count=16}\n``` {.python .cell-code}\nx1 = np.array([1])\nx2 = np.array([5])\n# Dup() duplicates the Top of Stack and returns the stack\ndl = tl.Dup()\ndl(x1)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n(array([1]), array([1]))\n```\n:::\n:::\n\n\n::: {#41310c81 .cell execution_count=17}\n``` {.python .cell-code}\n# ReversibleSwap() duplicates the Top of Stack and returns the stack\nsl = tl.ReversibleSwap()\nsl([x1, x2])\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n(array([5]), array([1]))\n```\n:::\n:::\n\n\nYou are no doubt wondering \"How is ReversibleSwap different from Swap?\". Good question! Lets look:\n<img src = \"Revnet5.PNG\" height=\"389\" width=\"1000\">\n<center><b>Figure 11: Two versions of Swap() </b></center>\nThe ReverseXYZ functions include a \"reverse\" compliment to their \"forward\" function that provides the functionality to run in reverse when doing backpropagation. It can also be run in reverse by simply calling 'reverse'.\n\n::: {#8c8e897f .cell execution_count=18}\n``` {.python .cell-code}\n# Demonstrate reverse swap\nprint(x1, x2, sl.reverse([x1, x2]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] [5] (array([5]), array([1]))\n```\n:::\n:::\n\n\nLet's try ReversibleHalfResidual, First we'll need some layers..\n\n::: {#1011c6f0 .cell execution_count=19}\n``` {.python .cell-code}\nFl = tl.Fn(\"F\", lambda x0: (2 * x0), n_out=1)\nGl = tl.Fn(\"G\", lambda x0: (10 * x0), n_out=1)\n```\n:::\n\n\nJust a note about ReversibleHalfResidual. As this is written, it resides in the Reformer model and is a layer. It is invoked a bit differently that other layers. Rather than tl.XYZ, it is just ReversibleHalfResidual(layers..) as shown below. This may change in the future.\n\n::: {#0f89f722 .cell execution_count=20}\n``` {.python .cell-code}\nhalf_res_F = ReversibleHalfResidual(Fl)\nprint(type(half_res_F), \"\\n\", half_res_F)\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">NameError</span>                                 Traceback (most recent call last)\nCell <span class=\"ansi-green-fg\">In[19], line 1</span>\n<span class=\"ansi-green-fg\">----&gt; 1</span> half_res_F <span style=\"color:rgb(98,98,98)\">=</span> <span class=\"ansi-yellow-bg\">ReversibleHalfResidual</span>(Fl)\n<span class=\"ansi-green-fg ansi-bold\">      2</span> <span style=\"color:rgb(0,135,0)\">print</span>(<span style=\"color:rgb(0,135,0)\">type</span>(half_res_F), <span style=\"color:rgb(175,0,0)\">\"</span><span style=\"font-weight:bold;color:rgb(175,95,0)\">\\n</span><span style=\"color:rgb(175,0,0)\">\"</span>, half_res_F)\n\n<span class=\"ansi-red-fg\">NameError</span>: name 'ReversibleHalfResidual' is not defined</pre>\n```\n:::\n\n:::\n:::\n\n\n::: {#57dd7781 .cell execution_count=21}\n``` {.python .cell-code}\nhalf_res_F([x1, x1])  # this is going to produce an error - why?\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">NameError</span>                                 Traceback (most recent call last)\nCell <span class=\"ansi-green-fg\">In[20], line 1</span>\n<span class=\"ansi-green-fg\">----&gt; 1</span> <span class=\"ansi-yellow-bg\">half_res_F</span>([x1, x1])  <span style=\"font-style:italic;color:rgb(95,135,135)\"># this is going to produce an error - why?</span>\n\n<span class=\"ansi-red-fg\">NameError</span>: name 'half_res_F' is not defined</pre>\n```\n:::\n\n:::\n:::\n\n\n::: {#e5a0be0f .cell execution_count=22}\n``` {.python .cell-code}\n# we have to initialize the ReversibleHalfResidual layer to let it know what the input is going to look like\nhalf_res_F.init(shapes.signature([x1, x1]))\nhalf_res_F([x1, x1])\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">NameError</span>                                 Traceback (most recent call last)\nCell <span class=\"ansi-green-fg\">In[21], line 2</span>\n<span class=\"ansi-green-fg ansi-bold\">      1</span> <span style=\"font-style:italic;color:rgb(95,135,135)\"># we have to initialize the ReversibleHalfResidual layer to let it know what the input is going to look like</span>\n<span class=\"ansi-green-fg\">----&gt; 2</span> <span class=\"ansi-yellow-bg\">half_res_F</span><span style=\"color:rgb(98,98,98)\">.</span>init(shapes<span style=\"color:rgb(98,98,98)\">.</span>signature([x1, x1]))\n<span class=\"ansi-green-fg ansi-bold\">      3</span> half_res_F([x1, x1])\n\n<span class=\"ansi-red-fg\">NameError</span>: name 'half_res_F' is not defined</pre>\n```\n:::\n\n:::\n:::\n\n\nNotice the output: (DeviceArray([3], dtype=int32), array([1])). The first value, (DeviceArray([3], dtype=int32) is the output of the \"Fl\" layer and has been converted to a 'Jax' DeviceArray. The second array([1]) is just passed through (recall the diagram of ReversibleHalfResidual above).\n\nThe final layer we need is the ReversibleSerial Layer. This is the reversible equivalent of the Serial layer and is used in the same manner to build a sequence of layers.\n\n<a name=\"2.2\"></a>\n### Part 2.2  Build a reversible model\nWe now have all the layers we need to build the model shown below. Let's build it in two parts. First we'll build 'blk' and then a list of blk's. And then 'mod'.\n<center><img src = \"Revnet6.PNG\" height=\"800\" width=\"1600\"> </center>\n<center><b>Figure 12: Reversible Model we will build using Trax components </b></center>\n\n::: {#81c0cdbe .cell execution_count=23}\n``` {.python .cell-code}\nblk = [  # a list of the 4 layers shown above\n    ### START CODE HERE ###\n    None,\n    None,\n    None,\n    None,\n]\nblks = [None, None]\n### END CODE HERE ###\n```\n:::\n\n\n::: {#6d670941 .cell execution_count=24}\n``` {.python .cell-code}\nmod = tl.Serial(\n    ### START CODE HERE ###\n    None,\n    None,\n    None,\n    ### END CODE HERE ###\n)\nmod\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/home/oren/work/notes/notes-nlp/.venv/lib/python3.10/site-packages/trax/layers/combinators.py:437: SyntaxWarning: \"is not\" with a literal. Did you mean \"!=\"?\n  if self._mode == 'predict' and self._state[1] is not ():  # pylint: disable=literal-comparison\n/home/oren/work/notes/notes-nlp/.venv/lib/python3.10/site-packages/trax/layers/combinators.py:910: SyntaxWarning: \"is\" with a literal. Did you mean \"==\"?\n  if state[0] is ():  # pylint: disable=literal-comparison\n/home/oren/work/notes/notes-nlp/.venv/lib/python3.10/site-packages/trax/layers/combinators.py:437: SyntaxWarning: \"is not\" with a literal. Did you mean \"!=\"?\n  if self._mode == 'predict' and self._state[1] is not ():  # pylint: disable=literal-comparison\n/home/oren/work/notes/notes-nlp/.venv/lib/python3.10/site-packages/trax/layers/combinators.py:910: SyntaxWarning: \"is\" with a literal. Did you mean \"==\"?\n  if state[0] is ():  # pylint: disable=literal-comparison\n```\n:::\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">ValueError</span>                                Traceback (most recent call last)\nCell <span class=\"ansi-green-fg\">In[23], line 1</span>\n<span class=\"ansi-green-fg\">----&gt; 1</span> mod <span style=\"color:rgb(98,98,98)\">=</span> <span class=\"ansi-yellow-bg\">tl</span><span style=\"color:rgb(98,98,98)\" class=\"ansi-yellow-bg\">.</span><span class=\"ansi-yellow-bg\">Serial</span><span class=\"ansi-yellow-bg\">(</span>\n<span class=\"ansi-green-fg ansi-bold\">      2</span> <span class=\"ansi-yellow-bg\">    </span><span style=\"font-style:italic;color:rgb(95,135,135)\" class=\"ansi-yellow-bg\">### START CODE HERE ###</span>\n<span class=\"ansi-green-fg ansi-bold\">      3</span> <span class=\"ansi-yellow-bg\">    </span><span style=\"font-weight:bold;color:rgb(0,135,0)\" class=\"ansi-yellow-bg\">None</span><span class=\"ansi-yellow-bg\">,</span>\n<span class=\"ansi-green-fg ansi-bold\">      4</span> <span class=\"ansi-yellow-bg\">    </span><span style=\"font-weight:bold;color:rgb(0,135,0)\" class=\"ansi-yellow-bg\">None</span><span class=\"ansi-yellow-bg\">,</span>\n<span class=\"ansi-green-fg ansi-bold\">      5</span> <span class=\"ansi-yellow-bg\">    </span><span style=\"font-weight:bold;color:rgb(0,135,0)\" class=\"ansi-yellow-bg\">None</span><span class=\"ansi-yellow-bg\">,</span>\n<span class=\"ansi-green-fg ansi-bold\">      6</span> <span class=\"ansi-yellow-bg\">    </span><span style=\"font-style:italic;color:rgb(95,135,135)\" class=\"ansi-yellow-bg\">### END CODE HERE ###</span>\n<span class=\"ansi-green-fg ansi-bold\">      7</span> <span class=\"ansi-yellow-bg\">)</span>\n<span class=\"ansi-green-fg ansi-bold\">      8</span> mod\n\nFile <span class=\"ansi-green-fg\">~/work/notes/notes-nlp/.venv/lib/python3.10/site-packages/trax/layers/combinators.py:59</span>, in <span class=\"ansi-cyan-fg\">Serial.__init__</span><span class=\"ansi-blue-fg\">(self, name, sublayers_to_print, *sublayers)</span>\n<span class=\"ansi-green-fg ansi-bold\">     55</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">def</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"color:rgb(0,0,255)\">__init__</span>(<span style=\"color:rgb(0,135,0)\">self</span>, <span style=\"color:rgb(98,98,98)\">*</span>sublayers, name<span style=\"color:rgb(98,98,98)\">=</span><span style=\"font-weight:bold;color:rgb(0,135,0)\">None</span>, sublayers_to_print<span style=\"color:rgb(98,98,98)\">=</span><span style=\"font-weight:bold;color:rgb(0,135,0)\">None</span>):\n<span class=\"ansi-green-fg ansi-bold\">     56</span>   <span style=\"color:rgb(0,135,0)\">super</span>()<span style=\"color:rgb(98,98,98)\">.</span><span style=\"color:rgb(0,0,255)\">__init__</span>(\n<span class=\"ansi-green-fg ansi-bold\">     57</span>       name<span style=\"color:rgb(98,98,98)\">=</span>name, sublayers_to_print<span style=\"color:rgb(98,98,98)\">=</span>sublayers_to_print)\n<span class=\"ansi-green-fg\">---&gt; 59</span>   sublayers <span style=\"color:rgb(98,98,98)\">=</span> <span class=\"ansi-yellow-bg\">_ensure_flat</span><span class=\"ansi-yellow-bg\">(</span><span class=\"ansi-yellow-bg\">sublayers</span><span class=\"ansi-yellow-bg\">)</span>\n<span class=\"ansi-green-fg ansi-bold\">     60</span>   <span style=\"color:rgb(0,135,0)\">self</span><span style=\"color:rgb(98,98,98)\">.</span>_sublayers <span style=\"color:rgb(98,98,98)\">=</span> sublayers\n<span class=\"ansi-green-fg ansi-bold\">     61</span>   <span style=\"color:rgb(0,135,0)\">self</span><span style=\"color:rgb(98,98,98)\">.</span>_n_layers <span style=\"color:rgb(98,98,98)\">=</span> <span style=\"color:rgb(0,135,0)\">len</span>(sublayers)\n\nFile <span class=\"ansi-green-fg\">~/work/notes/notes-nlp/.venv/lib/python3.10/site-packages/trax/layers/combinators.py:1110</span>, in <span class=\"ansi-cyan-fg\">_ensure_flat</span><span class=\"ansi-blue-fg\">(layers)</span>\n<span class=\"ansi-green-fg ansi-bold\">   1108</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">for</span> obj <span style=\"font-weight:bold;color:rgb(175,0,255)\">in</span> layers:\n<span class=\"ansi-green-fg ansi-bold\">   1109</span>   <span style=\"font-weight:bold;color:rgb(0,135,0)\">if</span> <span style=\"font-weight:bold;color:rgb(175,0,255)\">not</span> <span style=\"color:rgb(0,135,0)\">isinstance</span>(obj, base<span style=\"color:rgb(98,98,98)\">.</span>Layer):\n<span class=\"ansi-green-fg\">-&gt; 1110</span>     <span style=\"font-weight:bold;color:rgb(0,135,0)\">raise</span> <span style=\"font-weight:bold;color:rgb(215,95,95)\">ValueError</span>(\n<span class=\"ansi-green-fg ansi-bold\">   1111</span>         <span style=\"color:rgb(175,0,0)\">f</span><span style=\"color:rgb(175,0,0)\">'</span><span style=\"color:rgb(175,0,0)\">Found nonlayer object (</span><span style=\"font-weight:bold;color:rgb(175,95,135)\">{</span>obj<span style=\"font-weight:bold;color:rgb(175,95,135)\">}</span><span style=\"color:rgb(175,0,0)\">) in layers: </span><span style=\"font-weight:bold;color:rgb(175,95,135)\">{</span>layers<span style=\"font-weight:bold;color:rgb(175,95,135)\">}</span><span style=\"color:rgb(175,0,0)\">'</span>)\n<span class=\"ansi-green-fg ansi-bold\">   1112</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">return</span> layers\n\n<span class=\"ansi-red-fg\">ValueError</span>: Found nonlayer object (None) in layers: [None, None, None]</pre>\n```\n:::\n\n:::\n:::\n\n\n**Expected Output**\n```\nSerial[\n  Dup_out2\n  ReversibleSerial_in2_out2[\n    ReversibleHalfResidualV2_in2_out2[\n      Serial[\n        F\n      ]\n    ]\n    ReversibleSwap_in2_out2\n    ReversibleHalfResidualV2_in2_out2[\n      Serial[\n        G\n      ]\n    ]\n    ReversibleSwap_in2_out2\n    ReversibleHalfResidualV2_in2_out2[\n      Serial[\n        F\n      ]\n    ]\n    ReversibleSwap_in2_out2\n    ReversibleHalfResidualV2_in2_out2[\n      Serial[\n        G\n      ]\n    ]\n    ReversibleSwap_in2_out2\n  ]\n  Concatenate_in2\n]\n```\n\n::: {#faaacbbc .cell execution_count=25}\n``` {.python .cell-code}\nmod.init(shapes.signature(x1))\nout = mod(x1)\nout\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">NameError</span>                                 Traceback (most recent call last)\nCell <span class=\"ansi-green-fg\">In[24], line 1</span>\n<span class=\"ansi-green-fg\">----&gt; 1</span> <span class=\"ansi-yellow-bg\">mod</span><span style=\"color:rgb(98,98,98)\">.</span>init(shapes<span style=\"color:rgb(98,98,98)\">.</span>signature(x1))\n<span class=\"ansi-green-fg ansi-bold\">      2</span> out <span style=\"color:rgb(98,98,98)\">=</span> mod(x1)\n<span class=\"ansi-green-fg ansi-bold\">      3</span> out\n\n<span class=\"ansi-red-fg\">NameError</span>: name 'mod' is not defined</pre>\n```\n:::\n\n:::\n:::\n\n\n**Expected Result**\nDeviceArray([ 65, 681], dtype=int32)\n\nOK, now you have had a chance to try all the 'Reversible' functions in Trax. On to the Assignment!\n\n",
    "supporting": [
      "lab02_files"
    ],
    "filters": [],
    "includes": {}
  }
}