{
  "hash": "dc70f7c1292ed41a8c8026d19bcd05d1",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ndate: 2020-10-23\ntitle: Parts-of-Speech Tagging - Working with tags and Numpy\nsubtitle: \"Probabilistic Models\"\ndescription: \"In this lab you will create a matrix using some tag information and then modify it using different approaches. This will serve as hands-on experience working with Numpy\"\ncategories: \n  - NLP \n  - Coursera \n  - lab\n  - Probabilistic Models\njupyter: python3\n---\n\n\n\n\n![course banner](img/course-banner.jpg){.column-margin}\n\nIn this lecture notebook you will create a matrix using some tag information and then modify it using different approaches.\nThis will serve as hands-on experience working with Numpy and as an introduction to some elements used for POS tagging.\n\n::: {#b5e4f90f .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\n```\n:::\n\n\n### Some information on tags\n\nFor this notebook you will be using a toy example including only three tags (or states). In a real world application there are many more tags which can be found [here](https://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html).\n\n::: {#b28ccacb .cell execution_count=2}\n``` {.python .cell-code}\n# Define tags for Adverb, Noun and To (the preposition) , respectively\ntags = ['RB', 'NN', 'TO']\n```\n:::\n\n\nIn this week's assignment you will construct some dictionaries that provide useful information of the tags and words you will be working with. \n\nOne of these dictionaries is the `transition_counts` which counts the number of times a particular tag happened next to another. The keys of this dictionary have the form `(previous_tag, tag)` and the values are the frequency of occurrences.\n\nAnother one is the `emission_counts` dictionary which will count the number of times a particular pair of `(tag, word)` appeared in the training dataset.\n\nIn general think of `transition` when working with tags only and of `emission` when working with tags and words.\n\nIn this notebook you will be looking at the first one:\n\n::: {#e5c905bf .cell execution_count=3}\n``` {.python .cell-code}\n# Define 'transition_counts' dictionary\n# Note: values are the same as the ones in the assignment\ntransition_counts = {\n    ('NN', 'NN'): 16241,\n    ('RB', 'RB'): 2263,\n    ('TO', 'TO'): 2,\n    ('NN', 'TO'): 5256,\n    ('RB', 'TO'): 855,\n    ('TO', 'NN'): 734,\n    ('NN', 'RB'): 2431,\n    ('RB', 'NN'): 358,\n    ('TO', 'RB'): 200\n}\n```\n:::\n\n\nNotice that there are 9 combinations of the 3 tags used. Each tag can appear after the same tag so you should include those as well.\n\n### Using Numpy for matrix creation\n\nNow you will create a matrix that includes these frequencies using Numpy arrays:\n\n::: {#da709b33 .cell execution_count=4}\n``` {.python .cell-code}\n# Store the number of tags in the 'num_tags' variable\nnum_tags = len(tags)\n\n# Initialize a 3X3 numpy array with zeros\ntransition_matrix = np.zeros((num_tags, num_tags))\n\n# Print matrix\ntransition_matrix\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\narray([[0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.]])\n```\n:::\n:::\n\n\nVisually you can see the matrix has the correct dimensions. Don't forget you can check this too using the `shape` attribute:\n\n::: {#cbb09b0a .cell execution_count=5}\n``` {.python .cell-code}\n# Print shape of the matrix\ntransition_matrix.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n(3, 3)\n```\n:::\n:::\n\n\nBefore filling this matrix with the values of the `transition_counts` dictionary you should sort the tags so that their placement in the matrix is consistent:\n\n::: {#0620b88f .cell execution_count=6}\n``` {.python .cell-code}\n# Create sorted version of the tag's list\nsorted_tags = sorted(tags)\n\n# Print sorted list\nsorted_tags\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n['NN', 'RB', 'TO']\n```\n:::\n:::\n\n\nTo fill this matrix with the correct values you can use a `double for loop`. You could also use `itertools.product` to one line this double loop:\n\n::: {#d457ae2c .cell execution_count=7}\n``` {.python .cell-code}\n# Loop rows\nfor i in range(num_tags):\n    # Loop columns\n    for j in range(num_tags):\n        # Define tag pair\n        tag_tuple = (sorted_tags[i], sorted_tags[j])\n        # Get frequency from transition_counts dict and assign to (i, j) position in the matrix\n        transition_matrix[i, j] = transition_counts.get(tag_tuple)\n\n# Print matrix\ntransition_matrix\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\narray([[1.6241e+04, 2.4310e+03, 5.2560e+03],\n       [3.5800e+02, 2.2630e+03, 8.5500e+02],\n       [7.3400e+02, 2.0000e+02, 2.0000e+00]])\n```\n:::\n:::\n\n\nLooks like this worked fine. However the matrix can be hard to read as `Numpy` is more about efficiency, rather than presenting values in a pretty format. \n\nFor this you can use a `Pandas DataFrame`. In particular, a function that takes the matrix as input and prints out a pretty version of it will be very useful:\n\n::: {#3f5543ef .cell execution_count=8}\n``` {.python .cell-code}\n# Define 'print_matrix' function\ndef print_matrix(matrix):\n    print(pd.DataFrame(matrix, index=sorted_tags, columns=sorted_tags))\n```\n:::\n\n\nNotice that the tags are not a parameter of the function. This is because the `sorted_tags` list will not change in the rest of the notebook so it is safe to use the variable previously declared. To test this function simply run: \n\n::: {#cda24d85 .cell execution_count=9}\n``` {.python .cell-code}\n# Print the 'transition_matrix' by calling the 'print_matrix' function\nprint_matrix(transition_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         NN      RB      TO\nNN  16241.0  2431.0  5256.0\nRB    358.0  2263.0   855.0\nTO    734.0   200.0     2.0\n```\n:::\n:::\n\n\nThat is a lot better, isn't it? \n\nAs you may have already deducted this matrix is not symmetrical.\n\n### Working with Numpy for matrix manipulation\n\nNow that you got the matrix set up it is time to see how a matrix can be manipulated after being created. \n\n`Numpy` allows vectorized operations which means that operations that would normally include looping over the matrix can be done in a simpler manner. This is consistent with treating numpy arrays as matrices since you get support for common matrix operations. You can do matrix multiplication, scalar multiplication, vector addition and many more!\n\nFor instance try scaling each value in the matrix by a factor of $\\frac{1}{10}$. Normally you would loop over each value in the matrix, updating them accordingly. But in Numpy this is as easy as dividing the whole matrix by 10:\n\n::: {#45c375d8 .cell execution_count=10}\n``` {.python .cell-code}\n# Scale transition matrix\ntransition_matrix = transition_matrix/10\n\n# Print scaled matrix\nprint_matrix(transition_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        NN     RB     TO\nNN  1624.1  243.1  525.6\nRB    35.8  226.3   85.5\nTO    73.4   20.0    0.2\n```\n:::\n:::\n\n\nAnother trickier example is to normalize each row so that each value is equal to $\\frac{value}{sum \\,of \\,row}$.\n\nThis can be easily done with vectorization. First you will compute the sum of each row:\n\n::: {#238d37b3 .cell execution_count=11}\n``` {.python .cell-code}\n# Compute sum of row for each row\nrows_sum = transition_matrix.sum(axis=1, keepdims=True)\n\n# Print sum of rows\nrows_sum\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\narray([[2392.8],\n       [ 347.6],\n       [  93.6]])\n```\n:::\n:::\n\n\nNotice that the `sum()` method was used. This method does exactly what its name implies. Since the sum of the rows was desired the axis was set to `1`. In Numpy `axis=1` refers to the columns so the sum is done by summing each column of a particular row, for each row. \n\nAlso the `keepdims` parameter was set to `True` so the resulting array had shape `(3, 1)` rather than `(3,)`. This was done so that the axes were consistent with the desired operation. \n\nWhen working with Numpy, always remember to check the shape of the arrays you are working with, many unexpected errors happen because of axes not being consistent. The `shape` attribute is your friend for these cases.\n\n::: {#cd9eb9ef .cell execution_count=12}\n``` {.python .cell-code}\n# Normalize transition matrix\ntransition_matrix = transition_matrix / rows_sum\n\n# Print normalized matrix\nprint_matrix(transition_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          NN        RB        TO\nNN  0.678745  0.101596  0.219659\nRB  0.102992  0.651036  0.245972\nTO  0.784188  0.213675  0.002137\n```\n:::\n:::\n\n\nNotice that the normalization that was carried out forces the sum of each row to be equal to `1`. You can easily check this by running the `sum` method on the resulting matrix:\n\n::: {#c3d4a6ef .cell execution_count=13}\n``` {.python .cell-code}\ntransition_matrix.sum(axis=1, keepdims=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\narray([[1.],\n       [1.],\n       [1.]])\n```\n:::\n:::\n\n\nFor a final example you are asked to modify each value of the diagonal of the matrix so that they are equal to the `log` of the sum of the current row plus the current value. When doing mathematical operations like this one don't forget to import the `math` module. \n\nThis can be done using a standard `for loop` or `vectorization`. You'll see both in action:\n\n::: {#0bd5b8d7 .cell execution_count=14}\n``` {.python .cell-code}\nimport math\n\n# Copy transition matrix for for-loop example\nt_matrix_for = np.copy(transition_matrix)\n\n# Copy transition matrix for numpy functions example\nt_matrix_np = np.copy(transition_matrix)\n```\n:::\n\n\n#### Using a for-loop\n\n::: {#4d2ed022 .cell execution_count=15}\n``` {.python .cell-code}\n# Loop values in the diagonal\nfor i in range(num_tags):\n    t_matrix_for[i, i] =  t_matrix_for[i, i] + math.log(rows_sum[i])\n\n# Print matrix\nprint_matrix(t_matrix_for)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          NN        RB        TO\nNN  8.458964  0.101596  0.219659\nRB  0.102992  6.502088  0.245972\nTO  0.784188  0.213675  4.541167\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n/tmp/ipykernel_128834/84584535.py:3: DeprecationWarning: Conversion of an array with ndim > 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  t_matrix_for[i, i] =  t_matrix_for[i, i] + math.log(rows_sum[i])\n```\n:::\n:::\n\n\n#### Using vectorization\n\n::: {#c7e39d29 .cell execution_count=16}\n``` {.python .cell-code}\n# Save diagonal in a numpy array\nd = np.diag(t_matrix_np)\n\n# Print shape of diagonal\nd.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n(3,)\n```\n:::\n:::\n\n\nYou can save the diagonal in a numpy array using Numpy's `diag()` function. Notice that this array has shape `(3,)` so it is inconsistent with the dimensions of the `rows_sum` array which are `(3, 1)`. You'll have to reshape before moving forward. For this you can use Numpy's `reshape()` function, specifying the desired shape in a tuple:\n\n::: {#df013cd8 .cell execution_count=17}\n``` {.python .cell-code}\n# Reshape diagonal numpy array\nd = np.reshape(d, (3,1))\n\n# Print shape of diagonal\nd.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n(3, 1)\n```\n:::\n:::\n\n\nNow that the diagonal has the correct shape you can do the vectorized operation by applying the `math.log()` function to the `rows_sum` array and adding the diagonal. \n\nTo apply a function to each element of a numpy array use Numpy's `vectorize()` function providing the desired function as a parameter. This function returns a vectorized function that accepts a numpy array as a parameter. \n\nTo update the original matrix you can use Numpy's `fill_diagonal()` function.\n\n::: {#1417aa82 .cell execution_count=18}\n``` {.python .cell-code}\n# Perform the vectorized operation\nd = d + np.vectorize(math.log)(rows_sum)\n\n# Use numpy's 'fill_diagonal' function to update the diagonal\nnp.fill_diagonal(t_matrix_np, d)\n\n# Print the matrix\nprint_matrix(t_matrix_np)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          NN        RB        TO\nNN  8.458964  0.101596  0.219659\nRB  0.102992  6.502088  0.245972\nTO  0.784188  0.213675  4.541167\n```\n:::\n:::\n\n\nTo perform a sanity check that both methods yield the same result you can compare both matrices. Notice that this operation is also vectorized so you will get the equality check for each element in both matrices:\n\n::: {#74d748bc .cell execution_count=19}\n``` {.python .cell-code}\n# Check for equality\nt_matrix_for == t_matrix_np\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\narray([[ True,  True,  True],\n       [ True,  True,  True],\n       [ True,  True,  True]])\n```\n:::\n:::\n\n\n**Congratulations on finishing this lecture notebook!** Now you should be more familiar with some elements used by a POS tagger such as the `transition_counts` dictionary and with working with Numpy.\n\n**Keep it up!**\n\n",
    "supporting": [
      "lab02_files"
    ],
    "filters": [],
    "includes": {}
  }
}