{
  "hash": "cd1d4bd2de34e855a310c17e7df3b417",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: SentencePiece and Byte Pair Encoding\nsubtitle: \"NLP with Attention Models\"\ncategories: \n  - NLP \n  - Coursera \n  - Lab\n  - NLP with Attention Models\njupyter: python3\n#execute: \n#    error: true\ndraft: false\n---\n\n\n\n\n![course banner](/images/Course-Logo-4-1.webp){.column-margin .nolightbox}\n\n\n## Introduction to Tokenization\n\nIn order to process text in neural network models, it is first required to **encode** text as numbers with ids (such as the embedding vectors we've been using in the previous assignments), since the tensor operations act on numbers. Finally, if the output of the network are words, it is required to **decode** the predicted tokens ids back to text.\n\nTo encode text, the first decision that has to be made is to what level of granularity are we going to consider the text? Because ultimately, from these **tokens**, features are going to be created about them. Many different experiments have been carried out using *words*, *morphological units*, *phonemic units*, *characters*. For example, \n\n- Tokens are tricky. (raw text)\n- Tokens are tricky . ([words](https://arxiv.org/pdf/1301.3781))\n- Token s _ are _ trick _ y . ([morphemes](https://arxiv.org/pdf/1907.02423.pdf))\n- t oʊ k ə n z _ ɑː _ ˈt r ɪ k i. ([phonemes](https://www.aclweb.org/anthology/W18-5812.pdf), for STT)\n- T o k e n s _ a r e _ t r i c k y . ([character](https://www.aclweb.org/anthology/C18-1139/))\n\nBut how to identify these units, such as words, are largely determined by the language they come from. For example, in many European languages a space is used to separate words, while in some Asian languages there are no spaces between words. Compare English and Mandarin.\n\n- Tokens are tricky. (original sentence)\n- 令牌很棘手 (Mandarin)\n- Lìng pái hěn jí shǒu (pinyin)\n- 令牌 很 棘手 (Mandarin with spaces)\n\n\nSo, the ability to **tokenize**, i.e. split text into meaningful fundamental units is not always straight-forward.\n\nAlso, there are practical issues of how large our *vocabulary* of words, `vocab_size`, should be, considering memory limitations vs. coverage. A compromise between the finest-grained models employing characters which can be memory and more computationally efficient *subword* units such as [n-grams](https://arxiv.org/pdf/1712.09405) or larger units need to be made.\n\nIn [SentencePiece](https://www.aclweb.org/anthology/D18-2012.pdf) unicode characters are grouped together using either a [unigram language model](https://www.aclweb.org/anthology/P18-1007.pdf) (used in this week's assignment) or [BPE](https://arxiv.org/pdf/1508.07909.pdf), **byte-pair encoding**. We will discuss BPE, since BERT and many of its variant uses a modified version of BPE and its pseudocode is easy to implement and understand... hopefully!\n\n## SentencePiece Preprocessing\n\n### NFKC Normalization\n\nUnsurprisingly, even using unicode to initially tokenize text can be ambiguous, e.g., \n\n::: {#9f4d78f8 .cell execution_count=2}\n``` {.python .cell-code}\neaccent = '\\u00E9'\ne_accent = '\\u0065\\u0301'\nprint(f'{eaccent} = {e_accent} : {eaccent == e_accent}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\né = é : False\n```\n:::\n:::\n\n\nSentencePiece uses the Unicode standard Normalization form, [NFKC](https://en.wikipedia.org/wiki/Unicode_equivalence), so this isn't an issue. Looking at our example from above again with normalization:\n\n::: {#8057ab8a .cell execution_count=3}\n``` {.python .cell-code}\nfrom unicodedata import normalize\n\nnorm_eaccent = normalize('NFKC', '\\u00E9')\nnorm_e_accent = normalize('NFKC', '\\u0065\\u0301')\nprint(f'{norm_eaccent} = {norm_e_accent} : {norm_eaccent == norm_e_accent}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\né = é : True\n```\n:::\n:::\n\n\nNormalization has actually changed the unicode code point (unicode unique id) for one of these two characters.\n\n::: {#a6431054 .cell execution_count=4}\n``` {.python .cell-code}\ndef get_hex_encoding(s):\n    return ' '.join(hex(ord(c)) for c in s)\n\ndef print_string_and_encoding(s):\n    print(f'{s} : {get_hex_encoding(s)}') \n```\n:::\n\n\n::: {#144d05c1 .cell execution_count=5}\n``` {.python .cell-code}\nfor s in [eaccent, e_accent, norm_eaccent, norm_e_accent]:\n    print_string_and_encoding(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\né : 0xe9\né : 0x65 0x301\né : 0xe9\né : 0xe9\n```\n:::\n:::\n\n\nThis normalization has other side effects which may be considered useful such as converting curly quotes &ldquo; to \" their ASCII equivalent. (Although we *now* lose directionality of the quote...)\n\n### Lossless Tokenization<sup>*</sup>\n\nSentencePiece also ensures that when you tokenize your data and detokenize your data the original position of white space is preserved. (However, tabs and newlines are converted to spaces, please try this experiment yourself later below.)\n\nTo ensure this **lossless tokenization** it replaces white space with _ (U+2581). So that a simple join of the replace underscores with spaces can restore the white space, even if there are consecutives symbols. But remember first to normalize and then replace spaces with _ (U+2581). As the following example shows.\n\n::: {#61f4d157 .cell execution_count=6}\n``` {.python .cell-code}\ns = 'Tokenization is hard.'\ns_ = s.replace(' ', '\\u2581')\ns_n = normalize('NFKC', 'Tokenization is hard.')\n```\n:::\n\n\n::: {#a6111a48 .cell execution_count=7}\n``` {.python .cell-code}\nprint(get_hex_encoding(s))\nprint(get_hex_encoding(s_))\nprint(get_hex_encoding(s_n))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0x54 0x6f 0x6b 0x65 0x6e 0x69 0x7a 0x61 0x74 0x69 0x6f 0x6e 0x20 0x69 0x73 0x20 0x68 0x61 0x72 0x64 0x2e\n0x54 0x6f 0x6b 0x65 0x6e 0x69 0x7a 0x61 0x74 0x69 0x6f 0x6e 0x2581 0x69 0x73 0x2581 0x68 0x61 0x72 0x64 0x2e\n0x54 0x6f 0x6b 0x65 0x6e 0x69 0x7a 0x61 0x74 0x69 0x6f 0x6e 0x20 0x69 0x73 0x20 0x68 0x61 0x72 0x64 0x2e\n```\n:::\n:::\n\n\nSo the special unicode underscore was replaced by the ASCII unicode. Reversing the order, we see that the special unicode underscore was retained.\n\n::: {#bd98ac9b .cell execution_count=8}\n``` {.python .cell-code}\ns = 'Tokenization is hard.'\nsn = normalize('NFKC', 'Tokenization is hard.')\nsn_ = s.replace(' ', '\\u2581')\n```\n:::\n\n\n::: {#0863da7f .cell execution_count=9}\n``` {.python .cell-code}\nprint(get_hex_encoding(s))\nprint(get_hex_encoding(sn))\nprint(get_hex_encoding(sn_))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0x54 0x6f 0x6b 0x65 0x6e 0x69 0x7a 0x61 0x74 0x69 0x6f 0x6e 0x20 0x69 0x73 0x20 0x68 0x61 0x72 0x64 0x2e\n0x54 0x6f 0x6b 0x65 0x6e 0x69 0x7a 0x61 0x74 0x69 0x6f 0x6e 0x20 0x69 0x73 0x20 0x68 0x61 0x72 0x64 0x2e\n0x54 0x6f 0x6b 0x65 0x6e 0x69 0x7a 0x61 0x74 0x69 0x6f 0x6e 0x2581 0x69 0x73 0x2581 0x68 0x61 0x72 0x64 0x2e\n```\n:::\n:::\n\n\n## BPE Algorithm\n\nNow that we have discussed the preprocessing that SentencePiece performs we will go get our data, preprocess, and apply the BPE algorithm. We will show how this reproduces the tokenization produced by training SentencePiece on our example dataset (from this week's assignment).\n\n### Preparing our Data\nFirst, we get our Squad data and process as above.\n\n::: {#ef20a54a .cell execution_count=10}\n``` {.python .cell-code}\nimport ast\n\ndef convert_json_examples_to_text(filepath):\n    example_jsons = list(map(ast.literal_eval, open(filepath))) # Read in the json from the example file\n    texts = [example_json['text'].decode('utf-8') for example_json in example_jsons] # Decode the byte sequences\n    text = '\\n\\n'.join(texts)       # Separate different articles by two newlines\n    text = normalize('NFKC', text)  # Normalize the text\n\n    with open('example.txt', 'w') as fw:\n        fw.write(text)\n    \n    return text\n```\n:::\n\n\n::: {#28ecbfab .cell execution_count=11}\n``` {.python .cell-code}\ntext = convert_json_examples_to_text('data.txt')\nprint(text[:900])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBeginners BBQ Class Taking Place in Missoula!\nDo you want to get better at making delicious BBQ? You will have the opportunity, put this on your calendar now. Thursday, September 22nd join World Class BBQ Champion, Tony Balay from Lonestar Smoke Rangers. He will be teaching a beginner level class for everyone who wants to get better with their culinary skills.\nHe will teach you everything you need to know to compete in a KCBS BBQ competition, including techniques, recipes, timelines, meat selection and trimming, plus smoker and fire information.\nThe cost to be in the class is $35 per person, and for spectators it is free. Included in the cost will be either a t-shirt or apron and you will be tasting samples of each meat that is prepared.\n\nDiscussion in 'Mac OS X Lion (10.7)' started by axboi87, Jan 20, 2012.\nI've got a 500gb internal drive and a 240gb SSD.\nWhen trying to restore using di\n```\n:::\n:::\n\n\nIn the algorithm the `vocab` variable is actually a frequency dictionary of the words. Further, those words have been prepended with an *underscore* to indicate that they are the beginning of a word. Finally, the characters have been delimited by spaces so that the BPE algorithm can group the most common characters together in the dictionary in a greedy fashion. We will see how that is exactly done shortly.\n\n::: {#1a9d9fcd .cell execution_count=12}\n``` {.python .cell-code}\nfrom collections import Counter\n\nvocab = Counter(['\\u2581' + word for word in text.split()])\nvocab = {' '.join([l for l in word]): freq for word, freq in vocab.items()}\n```\n:::\n\n\n::: {#df479b2f .cell execution_count=13}\n``` {.python .cell-code}\ndef show_vocab(vocab, end='\\n', limit=20):\n    shown = 0\n    for word, freq in vocab.items():\n        print(f'{word}: {freq}', end=end)\n        shown +=1\n        if shown > limit:\n            break\n```\n:::\n\n\n::: {#fa527e9e .cell execution_count=14}\n``` {.python .cell-code}\nshow_vocab(vocab)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n▁ B e g i n n e r s: 1\n▁ B B Q: 3\n▁ C l a s s: 2\n▁ T a k i n g: 1\n▁ P l a c e: 1\n▁ i n: 15\n▁ M i s s o u l a !: 1\n▁ D o: 1\n▁ y o u: 13\n▁ w a n t: 1\n▁ t o: 33\n▁ g e t: 2\n▁ b e t t e r: 2\n▁ a t: 1\n▁ m a k i n g: 2\n▁ d e l i c i o u s: 1\n▁ B B Q ?: 1\n▁ Y o u: 1\n▁ w i l l: 6\n▁ h a v e: 4\n▁ t h e: 31\n```\n:::\n:::\n\n\nWe check the size of the vocabulary (frequency dictionary) because this is the one hyperparameter that BPE depends on crucially on how far it breaks up a word into SentencePieces. It turns out that for our trained model on our small dataset that 60% of 455 merges of the most frequent characters need to be done to reproduce the upperlimit of a 32K `vocab_size` over the entire corpus of examples.\n\n::: {#81cfa7d1 .cell execution_count=15}\n``` {.python .cell-code}\nprint(f'Total number of unique words: {len(vocab)}')\nprint(f'Number of merges required to reproduce SentencePiece training on the whole corpus: {int(0.60*len(vocab))}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTotal number of unique words: 455\nNumber of merges required to reproduce SentencePiece training on the whole corpus: 273\n```\n:::\n:::\n\n\n### BPE Algorithm\nDirectly from the BPE paper we have the following algorithm. \n\nTo understand what's going on first take a look at the third function `get_sentence_piece_vocab`. It takes in the current `vocab` word-frequency dictionary and the fraction of the total `vocab_size` to merge characters in the words of the dictionary, `num_merges` times. Then for each *merge* operation it `get_stats` on how many of each pair of character sequences there are. It gets the most frequent *pair* of symbols as the `best` pair. Then it merges those pair of symbols (removes the space between them) in each word in the `vocab` that contains this `best` (= `pair`). Consquently, `merge_vocab` creates a new `vocab`, `v_out`. This process is repeated `num_merges` times and the result is the set of SentencePieces (keys of the final `sp_vocab`).\n\nPlease feel free to skip the below if the above description was enough.\n\nIn a little more detail then, we can see in `get_stats` we initially create a list of bigram frequencies (two character sequence) from our vocabulary. Later, this may include (trigrams, quadgrams, etc.). Note that the key of the `pairs` frequency dictionary is actually a 2-tuple, which is just shorthand notation for a pair.\n\nIn `merge_vocab` we take in an individual `pair` (of character sequences, note this is the most frequency `best` pair) and the current `vocab` as `v_in`. We create a new `vocab`, `v_out`, from the old by joining together the characters in the pair (removing the space), if they are present in the a word of the dictionary. [Warning](https://regex101.com/): the expression `(?<!\\S)` means that either whitespace character follows before the `bigram` or there is nothing before (beginning of word) the bigram, similarly for `(?!\\S)` for preceding whitespace or end of word. \n\n::: {#c3b8f5c5 .cell execution_count=16}\n``` {.python .cell-code}\nimport re, collections\n\ndef get_stats(vocab):\n    pairs = collections.defaultdict(int)\n    for word, freq in vocab.items():\n        symbols = word.split()\n        for i in range(len(symbols) - 1):\n            pairs[symbols[i], symbols[i+1]] += freq\n    return pairs\n\ndef merge_vocab(pair, v_in):\n    v_out = {}\n    bigram = re.escape(' '.join(pair))\n    p = re.compile(r'(?<!\\S)' + bigram + r'(?!\\S)')\n    for word in v_in:\n        w_out = p.sub(''.join(pair), word)\n        v_out[w_out] = v_in[word]\n    return v_out\n\ndef get_sentence_piece_vocab(vocab, frac_merges=0.60):\n    sp_vocab = vocab.copy()\n    num_merges = int(len(sp_vocab)*frac_merges)\n    \n    for i in range(num_merges):\n        pairs = get_stats(sp_vocab)\n        best = max(pairs, key=pairs.get)\n        sp_vocab = merge_vocab(best, sp_vocab)\n\n    return sp_vocab\n```\n:::\n\n\n::: {#d6b5ea18 .cell execution_count=17}\n``` {.python .cell-code}\nsp_vocab = get_sentence_piece_vocab(vocab)\nshow_vocab(sp_vocab) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n▁B e g in n ers: 1\n▁BBQ: 3\n▁Cl ass: 2\n▁T ak ing: 1\n▁P la ce: 1\n▁in: 15\n▁M is s ou la !: 1\n▁D o: 1\n▁you: 13\n▁w an t: 1\n▁to: 33\n▁g et: 2\n▁be t ter: 2\n▁a t: 1\n▁mak ing: 2\n▁d e l ic i ou s: 1\n▁BBQ ?: 1\n▁ Y ou: 1\n▁will: 6\n▁have: 4\n▁the: 31\n```\n:::\n:::\n\n\n## Train SentencePiece BPE Tokenizer on Example Data\n### Explore SentencePiece Model\nFirst let us explore the SentencePiece model provided with this week's assignment. Remember you can always use Python's built in `help` command to see the documentation for any object or method.\n\n::: {#a4d417c4 .cell execution_count=18}\n``` {.python .cell-code}\nimport sentencepiece as spm\nsp = spm.SentencePieceProcessor(model_file='sentencepiece.model')\n```\n:::\n\n\n::: {#ccaad674 .cell execution_count=19}\n``` {.python .cell-code}\nhelp(sp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHelp on SentencePieceProcessor in module sentencepiece object:\n\nclass SentencePieceProcessor(builtins.object)\n |  SentencePieceProcessor(model_file=None, model_proto=None, out_type=<class 'int'>, add_bos=False, add_eos=False, reverse=False, emit_unk_piece=False, enable_sampling=False, nbest_size=-1, alpha=0.1, num_threads=-1)\n |  \n |  Methods defined here:\n |  \n |  CalculateEntropy(self, input, alpha, num_threads=None)\n |      Calculate sentence entropy\n |  \n |  Decode(self, input, out_type=<class 'str'>, num_threads=None)\n |      Decode processed id or token sequences.\n |      \n |      Args:\n |        out_type: output type. str, bytes or 'serialized_proto' or 'immutable_proto' (Default = str)\n |        num_threads: the number of threads used in the batch processing (Default = -1).\n |  \n |  DecodeIds(self, input, out_type=<class 'str'>, **kwargs)\n |  \n |  DecodeIdsAsImmutableProto(self, input, out_type='immutable_proto', **kwargs)\n |  \n |  DecodeIdsAsSerializedProto(self, input, out_type='serialized_proto', **kwargs)\n |  \n |  DecodePieces(self, input, out_type=<class 'str'>, **kwargs)\n |  \n |  DecodePiecesAsImmutableProto(self, input, out_type='immutable_proto', **kwargs)\n |  \n |  DecodePiecesAsSerializedProto(self, input, out_type='serialized_proto', **kwargs)\n |  \n |  Detokenize = Decode(self, input, out_type=<class 'str'>, num_threads=None)\n |  \n |  Encode(self, input, out_type=None, add_bos=None, add_eos=None, reverse=None, emit_unk_piece=None, enable_sampling=None, nbest_size=None, alpha=None, num_threads=None)\n |      Encode text input to segmented ids or tokens.\n |      \n |      Args:\n |      input: input string. accepsts list of string.\n |      out_type: output type. int or str.\n |      add_bos: Add <s> to the result (Default = false)\n |      add_eos: Add </s> to the result (Default = false) <s>/</s> is added after\n |               reversing (if enabled).\n |      reverse: Reverses the tokenized sequence (Default = false)\n |      emit_unk_piece: Emits the unk literal string (Default = false)\n |      nbest_size: sampling parameters for unigram. Invalid in BPE-Dropout.\n |                  nbest_size = {0,1}: No sampling is performed.\n |                  nbest_size > 1: samples from the nbest_size results.\n |                  nbest_size < 0: assuming that nbest_size is infinite and samples\n |                  from the all hypothesis (lattice) using\n |                  forward-filtering-and-backward-sampling algorithm.\n |      alpha: Soothing parameter for unigram sampling, and merge probability for\n |             BPE-dropout (probablity 'p' in BPE-dropout paper).\n |      num_threads: the number of threads used in the batch processing (Default = -1).\n |  \n |  EncodeAsIds(self, input, **kwargs)\n |  \n |  EncodeAsImmutableProto(self, input, **kwargs)\n |  \n |  EncodeAsPieces(self, input, **kwargs)\n |  \n |  EncodeAsSerializedProto(self, input, **kwargs)\n |  \n |  GetPieceSize(self)\n |  \n |  GetScore = _batched_func(self, arg)\n |  \n |  IdToPiece = _batched_func(self, arg)\n |  \n |  Init(self, model_file=None, model_proto=None, out_type=<class 'int'>, add_bos=False, add_eos=False, reverse=False, emit_unk_piece=False, enable_sampling=False, nbest_size=-1, alpha=0.1, num_threads=-1)\n |      Initialzie sentencepieceProcessor.\n |      \n |      Args:\n |        model_file: The sentencepiece model file path.\n |        model_proto: The sentencepiece model serialized proto.\n |        out_type: output type. int or str.\n |        add_bos: Add <s> to the result (Default = false)\n |        add_eos: Add </s> to the result (Default = false) <s>/</s> is added after\n |          reversing (if enabled).\n |        reverse: Reverses the tokenized sequence (Default = false)\n |        emit_unk_piece: Emits the unk literal string (Default = false)\n |        nbest_size: sampling parameters for unigram. Invalid in BPE-Dropout.\n |                    nbest_size = {0,1}: No sampling is performed.\n |                    nbest_size > 1: samples from the nbest_size results.\n |                    nbest_size < 0: assuming that nbest_size is infinite and samples\n |                      from the all hypothesis (lattice) using\n |                      forward-filtering-and-backward-sampling algorithm.\n |        alpha: Soothing parameter for unigram sampling, and dropout probability of\n |               merge operations for BPE-dropout.\n |        num_threads: number of threads in batch processing (Default = -1, auto-detected)\n |  \n |  IsByte = _batched_func(self, arg)\n |  \n |  IsControl = _batched_func(self, arg)\n |  \n |  IsUnknown = _batched_func(self, arg)\n |  \n |  IsUnused = _batched_func(self, arg)\n |  \n |  Load(self, model_file=None, model_proto=None)\n |      Overwride SentencePieceProcessor.Load to support both model_file and model_proto.\n |      \n |      Args:\n |        model_file: The sentencepiece model file path.\n |        model_proto: The sentencepiece model serialized proto. Either `model_file`\n |          or `model_proto` must be set.\n |  \n |  LoadFromFile(self, arg)\n |  \n |  LoadFromSerializedProto(self, serialized)\n |  \n |  LoadVocabulary(self, filename, threshold)\n |  \n |  NBestEncode(self, input, out_type=None, add_bos=None, add_eos=None, reverse=None, emit_unk_piece=None, nbest_size=None)\n |      NBestEncode text input to segmented ids or tokens.\n |      \n |      Args:\n |      input: input string. accepsts list of string.\n |      out_type: output type. int or str.\n |      add_bos: Add <s> to the result (Default = false)\n |      add_eos: Add </s> to the result (Default = false) <s>/</s> is added after reversing (if enabled).\n |      reverse: Reverses the tokenized sequence (Default = false)\n |      emit_unk_piece: Emits the unk literal string (Default = false)\n |      nbest_size: nbest size\n |  \n |  NBestEncodeAsIds(self, input, nbest_size=None, **kwargs)\n |  \n |  NBestEncodeAsImmutableProto(self, input, nbest_size=None, **kwargs)\n |  \n |  NBestEncodeAsPieces(self, input, nbest_size=None, **kwargs)\n |  \n |  NBestEncodeAsSerializedProto(self, input, nbest_size=None, **kwargs)\n |  \n |  Normalize(self, input, with_offsets=None)\n |  \n |  OverrideNormalizerSpec(self, **kwargs)\n |  \n |  PieceToId = _batched_func(self, arg)\n |  \n |  ResetVocabulary(self)\n |  \n |  SampleEncodeAndScore(self, input, out_type=None, add_bos=None, add_eos=None, reverse=None, emit_unk_piece=None, num_samples=None, alpha=None, wor=None, include_best=None)\n |      SampleEncodeAndScore text input to segmented ids or tokens.\n |      \n |      Args:\n |      input: input string. accepsts list of string.\n |      out_type: output type. int or str or 'serialized_proto' or 'immutable_proto'\n |      add_bos: Add <s> to the result (Default = false)\n |      add_eos: Add </s> to the result (Default = false) <s>/</s> is added after reversing (if enabled).\n |      reverse: Reverses the tokenized sequence (Default = false)\n |      emit_unk_piece: Emits the unk literal string (Default = false)\n |      num_samples: How many samples to return (Default = 1)\n |      alpha: inverse temperature for sampling\n |      wor: whether to sample without replacement (Default = false)\n |      include_best: whether to include the best tokenization, requires wor=True (Default = false)\n |  \n |  SampleEncodeAndScoreAsIds(self, input, num_samples=None, alpha=None, **kwargs)\n |  \n |  SampleEncodeAndScoreAsImmutableProto(self, input, num_samples=None, alpha=None, **kwargs)\n |  \n |  SampleEncodeAndScoreAsPieces(self, input, num_samples=None, alpha=None, **kwargs)\n |  \n |  SampleEncodeAndScoreAsSerializedProto(self, input, num_samples=None, alpha=None, **kwargs)\n |  \n |  SampleEncodeAsIds(self, input, nbest_size=None, alpha=None, **kwargs)\n |  \n |  SampleEncodeAsImmutableProto(self, input, nbest_size=None, alpha=None, **kwargs)\n |  \n |  SampleEncodeAsPieces(self, input, nbest_size=None, alpha=None, **kwargs)\n |  \n |  SampleEncodeAsSerializedProto(self, input, nbest_size=None, alpha=None, **kwargs)\n |  \n |  SetDecodeExtraOptions(self, extra_option)\n |  \n |  SetEncodeExtraOptions(self, extra_option)\n |  \n |  SetVocabulary(self, valid_vocab)\n |  \n |  Tokenize = Encode(self, input, out_type=None, add_bos=None, add_eos=None, reverse=None, emit_unk_piece=None, enable_sampling=None, nbest_size=None, alpha=None, num_threads=None)\n |  \n |  __getitem__(self, piece)\n |  \n |  __getstate__(self)\n |  \n |  __init__ = Init(self, model_file=None, model_proto=None, out_type=<class 'int'>, add_bos=False, add_eos=False, reverse=False, emit_unk_piece=False, enable_sampling=False, nbest_size=-1, alpha=0.1, num_threads=-1)\n |  \n |  __len__(self)\n |  \n |  __repr__ = _swig_repr(self)\n |  \n |  __setstate__(self, serialized_model_proto)\n |  \n |  bos_id(self)\n |  \n |  calculate_entropy = CalculateEntropy(self, input, alpha, num_threads=None)\n |  \n |  decode = Decode(self, input, out_type=<class 'str'>, num_threads=None)\n |  \n |  decode_ids = DecodeIds(self, input, out_type=<class 'str'>, **kwargs)\n |  \n |  decode_ids_as_immutable_proto = DecodeIdsAsImmutableProto(self, input, out_type='immutable_proto', **kwargs)\n |  \n |  decode_ids_as_serialized_proto = DecodeIdsAsSerializedProto(self, input, out_type='serialized_proto', **kwargs)\n |  \n |  decode_pieces = DecodePieces(self, input, out_type=<class 'str'>, **kwargs)\n |  \n |  decode_pieces_as_immutable_proto = DecodePiecesAsImmutableProto(self, input, out_type='immutable_proto', **kwargs)\n |  \n |  decode_pieces_as_serialized_proto = DecodePiecesAsSerializedProto(self, input, out_type='serialized_proto', **kwargs)\n |  \n |  detokenize = Decode(self, input, out_type=<class 'str'>, num_threads=None)\n |  \n |  encode = Encode(self, input, out_type=None, add_bos=None, add_eos=None, reverse=None, emit_unk_piece=None, enable_sampling=None, nbest_size=None, alpha=None, num_threads=None)\n |  \n |  encode_as_ids = EncodeAsIds(self, input, **kwargs)\n |  \n |  encode_as_immutable_proto = EncodeAsImmutableProto(self, input, **kwargs)\n |  \n |  encode_as_pieces = EncodeAsPieces(self, input, **kwargs)\n |  \n |  encode_as_serialized_proto = EncodeAsSerializedProto(self, input, **kwargs)\n |  \n |  eos_id(self)\n |  \n |  get_piece_size = GetPieceSize(self)\n |  \n |  get_score = _batched_func(self, arg)\n |  \n |  id_to_piece = _batched_func(self, arg)\n |  \n |  init = Init(self, model_file=None, model_proto=None, out_type=<class 'int'>, add_bos=False, add_eos=False, reverse=False, emit_unk_piece=False, enable_sampling=False, nbest_size=-1, alpha=0.1, num_threads=-1)\n |  \n |  is_byte = _batched_func(self, arg)\n |  \n |  is_control = _batched_func(self, arg)\n |  \n |  is_unknown = _batched_func(self, arg)\n |  \n |  is_unused = _batched_func(self, arg)\n |  \n |  load = Load(self, model_file=None, model_proto=None)\n |  \n |  load_from_file = LoadFromFile(self, arg)\n |  \n |  load_from_serialized_proto = LoadFromSerializedProto(self, serialized)\n |  \n |  load_vocabulary = LoadVocabulary(self, filename, threshold)\n |  \n |  nbest_encode = NBestEncode(self, input, out_type=None, add_bos=None, add_eos=None, reverse=None, emit_unk_piece=None, nbest_size=None)\n |  \n |  nbest_encode_as_ids = NBestEncodeAsIds(self, input, nbest_size=None, **kwargs)\n |  \n |  nbest_encode_as_immutable_proto = NBestEncodeAsImmutableProto(self, input, nbest_size=None, **kwargs)\n |  \n |  nbest_encode_as_pieces = NBestEncodeAsPieces(self, input, nbest_size=None, **kwargs)\n |  \n |  nbest_encode_as_serialized_proto = NBestEncodeAsSerializedProto(self, input, nbest_size=None, **kwargs)\n |  \n |  normalize = Normalize(self, input, with_offsets=None)\n |  \n |  override_normalizer_spec = OverrideNormalizerSpec(self, **kwargs)\n |  \n |  pad_id(self)\n |  \n |  piece_size(self)\n |  \n |  piece_to_id = _batched_func(self, arg)\n |  \n |  reset_vocabulary = ResetVocabulary(self)\n |  \n |  sample_encode_and_score = SampleEncodeAndScore(self, input, out_type=None, add_bos=None, add_eos=None, reverse=None, emit_unk_piece=None, num_samples=None, alpha=None, wor=None, include_best=None)\n |  \n |  sample_encode_and_score_as_ids = SampleEncodeAndScoreAsIds(self, input, num_samples=None, alpha=None, **kwargs)\n |  \n |  sample_encode_and_score_as_immutable_proto = SampleEncodeAndScoreAsImmutableProto(self, input, num_samples=None, alpha=None, **kwargs)\n |  \n |  sample_encode_and_score_as_pieces = SampleEncodeAndScoreAsPieces(self, input, num_samples=None, alpha=None, **kwargs)\n |  \n |  sample_encode_and_score_as_serialized_proto = SampleEncodeAndScoreAsSerializedProto(self, input, num_samples=None, alpha=None, **kwargs)\n |  \n |  sample_encode_as_ids = SampleEncodeAsIds(self, input, nbest_size=None, alpha=None, **kwargs)\n |  \n |  sample_encode_as_immutable_proto = SampleEncodeAsImmutableProto(self, input, nbest_size=None, alpha=None, **kwargs)\n |  \n |  sample_encode_as_pieces = SampleEncodeAsPieces(self, input, nbest_size=None, alpha=None, **kwargs)\n |  \n |  sample_encode_as_serialized_proto = SampleEncodeAsSerializedProto(self, input, nbest_size=None, alpha=None, **kwargs)\n |  \n |  serialized_model_proto(self)\n |  \n |  set_decode_extra_options = SetDecodeExtraOptions(self, extra_option)\n |  \n |  set_encode_extra_options = SetEncodeExtraOptions(self, extra_option)\n |  \n |  set_vocabulary = SetVocabulary(self, valid_vocab)\n |  \n |  tokenize = Encode(self, input, out_type=None, add_bos=None, add_eos=None, reverse=None, emit_unk_piece=None, enable_sampling=None, nbest_size=None, alpha=None, num_threads=None)\n |  \n |  unk_id(self)\n |  \n |  vocab_size(self)\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  __swig_destroy__ = delete_SentencePieceProcessor(...)\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  __dict__\n |      dictionary for instance variables (if defined)\n |  \n |  __weakref__\n |      list of weak references to the object (if defined)\n |  \n |  thisown\n |      The membership flag\n\n```\n:::\n:::\n\n\nLet's work with the first sentence of our example text.\n\n::: {#4561de0d .cell execution_count=20}\n``` {.python .cell-code}\ns0 = 'Beginners BBQ Class Taking Place in Missoula!'\n```\n:::\n\n\n::: {#7e9cddfd .cell execution_count=21}\n``` {.python .cell-code}\n# encode: text => id\nprint(sp.encode_as_pieces(s0))\nprint(sp.encode_as_ids(s0))\n\n# decode: id => text\nprint(sp.decode_pieces(sp.encode_as_pieces(s0)))\nprint(sp.decode_ids([12847, 277]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['▁Beginn', 'ers', '▁BBQ', '▁Class', '▁', 'Taking', '▁Place', '▁in', '▁Miss', 'oul', 'a', '!']\n[12847, 277, 15068, 4501, 3, 12297, 3399, 16, 5964, 7115, 9, 55]\nBeginners BBQ Class Taking Place in Missoula!\nBeginners\n```\n:::\n:::\n\n\nNotice how SentencePiece breaks the words into seemingly odd parts, but we've seen something similar from our work with BPE. But how close were we to this model trained on the whole corpus of examles with a `vocab_size` of 32,000 instead of 455? Here you can also test what happens to white space, like '\\n'. \n\nBut first let us note that SentencePiece encodes the SentencePieces, the tokens, and has reserved some of the ids as can be seen in this week's assignment.\n\n::: {#cd28e073 .cell execution_count=22}\n``` {.python .cell-code}\nuid = 15068\nspiece = \"\\u2581BBQ\"\nunknown = \"__MUST_BE_UNKNOWN__\"\n\n# id <=> piece conversion\nprint(f'SentencePiece for ID {uid}: {sp.id_to_piece(uid)}')\nprint(f'ID for Sentence Piece {spiece}: {sp.piece_to_id(spiece)}')\n\n# returns 0 for unknown tokens (we can change the id for UNK)\nprint(f'ID for unknown text {unknown}: {sp.piece_to_id(unknown)}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSentencePiece for ID 15068: ▁BBQ\nID for Sentence Piece ▁BBQ: 15068\nID for unknown text __MUST_BE_UNKNOWN__: 2\n```\n:::\n:::\n\n\n::: {#f4b2bb24 .cell execution_count=23}\n``` {.python .cell-code}\nprint(f'Beginning of sentence id: {sp.bos_id()}')\nprint(f'Pad id: {sp.pad_id()}')\nprint(f'End of sentence id: {sp.eos_id()}')\nprint(f'Unknown id: {sp.unk_id()}')\nprint(f'Vocab size: {sp.vocab_size()}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBeginning of sentence id: -1\nPad id: 0\nEnd of sentence id: 1\nUnknown id: 2\nVocab size: 32000\n```\n:::\n:::\n\n\nWe can also check what are the ids for the first part and last part of the vocabulary.\n\n::: {#83edfd35 .cell execution_count=24}\n``` {.python .cell-code}\nprint('\\nId\\tSentP\\tControl?')\nprint('------------------------')\n# <unk>, <s>, </s> are defined by default. Their ids are (0, 1, 2)\n# <s> and </s> are defined as 'control' symbol.\nfor uid in range(10):\n    print(uid, sp.id_to_piece(uid), sp.is_control(uid), sep='\\t')\n    \n# for uid in range(sp.vocab_size()-10,sp.vocab_size()):\n#     print(uid, sp.id_to_piece(uid), sp.is_control(uid), sep='\\t')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nId\tSentP\tControl?\n------------------------\n0\t<pad>\tTrue\n1\t</s>\tTrue\n2\t<unk>\tFalse\n3\t▁\tFalse\n4\tX\tFalse\n5\t.\tFalse\n6\t,\tFalse\n7\ts\tFalse\n8\t▁the\tFalse\n9\ta\tFalse\n```\n:::\n:::\n\n\n### Train SentencePiece BPE model with our example.txt\n\nFinally, let's train our own BPE model directly from the SentencePiece library and compare it to the results of our implemention of the algorithm from the BPE paper itself.\n\n::: {#6f8e7680 .cell execution_count=25}\n``` {.python .cell-code}\nspm.SentencePieceTrainer.train('--input=example.txt --model_prefix=example_bpe --vocab_size=450 --model_type=bpe')\nsp_bpe = spm.SentencePieceProcessor()\nsp_bpe.load('example_bpe.model')\n\nprint('*** BPE ***')\nprint(sp_bpe.encode_as_pieces(s0))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nsentencepiece_trainer.cc(178) LOG(INFO) Running command: --input=example.txt --model_prefix=example_bpe --vocab_size=450 --model_type=bpe\nsentencepiece_trainer.cc(78) LOG(INFO) Starts training with : \ntrainer_spec {\n  input: example.txt\n  input_format: \n  model_prefix: example_bpe\n  model_type: BPE\n  vocab_size: 450\n  self_test_sample_size: 0\n  character_coverage: 0.9995\n  input_sentence_size: 0\n  shuffle_input_sentence: 1\n  seed_sentencepiece_size: 1000000\n  shrinking_factor: 0.75\n  max_sentence_length: 4192\n  num_threads: 16\n  num_sub_iterations: 2\n  max_sentencepiece_length: 16\n  split_by_unicode_script: 1\n  split_by_number: 1\n  split_by_whitespace: 1\n  split_digits: 0\n  pretokenization_delimiter: \n  treat_whitespace_as_suffix: 0\n  allow_whitespace_only_pieces: 0\n  required_chars: \n  byte_fallback: 0\n  vocabulary_output_piece_score: 1\n  train_extremely_large_corpus: 0\n  seed_sentencepieces_file: \n  hard_vocab_limit: 1\n  use_all_vocab: 0\n  unk_id: 0\n  bos_id: 1\n  eos_id: 2\n  pad_id: -1\n  unk_piece: <unk>\n  bos_piece: <s>\n  eos_piece: </s>\n  pad_piece: <pad>\n  unk_surface:  ⁇ \n  enable_differential_privacy: 0\n  differential_privacy_noise_level: 0\n  differential_privacy_clipping_threshold: 0\n}\nnormalizer_spec {\n  name: nmt_nfkc\n  add_dummy_prefix: 1\n  remove_extra_whitespaces: 1\n  escape_whitespaces: 1\n  normalization_rule_tsv: \n}\ndenormalizer_spec {}\ntrainer_interface.cc(353) LOG(INFO) SentenceIterator is not specified. Using MultiFileSentenceIterator.\ntrainer_interface.cc(185) LOG(INFO) Loading corpus: example.txt\ntrainer_interface.cc(409) LOG(INFO) Loaded all 26 sentences\ntrainer_interface.cc(425) LOG(INFO) Adding meta_piece: <unk>\ntrainer_interface.cc(425) LOG(INFO) Adding meta_piece: <s>\ntrainer_interface.cc(425) LOG(INFO) Adding meta_piece: </s>\ntrainer_interface.cc(430) LOG(INFO) Normalizing sentences...\ntrainer_interface.cc(539) LOG(INFO) all chars count=4533\ntrainer_interface.cc(550) LOG(INFO) Done: 99.9559% characters are covered.\ntrainer_interface.cc(560) LOG(INFO) Alphabet size=73\ntrainer_interface.cc(561) LOG(INFO) Final character coverage=0.999559\ntrainer_interface.cc(592) LOG(INFO) Done! preprocessed 26 sentences.\ntrainer_interface.cc(598) LOG(INFO) Tokenizing input sentences with whitespace: 26\ntrainer_interface.cc(609) LOG(INFO) Done! 455\nbpe_model_trainer.cc(159) LOG(INFO) Updating active symbols. max_freq=99 min_freq=1\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=31 size=20 all=732 active=658 piece=▁w\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=16 size=40 all=937 active=863 piece=ch\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=11 size=60 all=1014 active=940 piece=▁u\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=8 size=80 all=1110 active=1036 piece=me\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=6 size=100 all=1166 active=1092 piece=la\nbpe_model_trainer.cc(159) LOG(INFO) Updating active symbols. max_freq=6 min_freq=0\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=5 size=120 all=1217 active=1042 piece=SD\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=5 size=140 all=1272 active=1097 piece=▁bu\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=5 size=160 all=1288 active=1113 piece=▁site\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=4 size=180 all=1315 active=1140 piece=ter\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=4 size=200 all=1330 active=1155 piece=asure\nbpe_model_trainer.cc(159) LOG(INFO) Updating active symbols. max_freq=4 min_freq=0\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=3 size=220 all=1339 active=1008 piece=ge\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=3 size=240 all=1371 active=1040 piece=▁sh\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=3 size=260 all=1384 active=1053 piece=▁cost\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=2 size=280 all=1391 active=1060 piece=de\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=2 size=300 all=1405 active=1074 piece=000\nbpe_model_trainer.cc(159) LOG(INFO) Updating active symbols. max_freq=2 min_freq=0\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=2 size=320 all=1427 active=1021 piece=▁GB\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=2 size=340 all=1438 active=1032 piece=last\nbpe_model_trainer.cc(268) LOG(INFO) Added: freq=2 size=360 all=1441 active=1035 piece=▁let\ntrainer_interface.cc(687) LOG(INFO) Saving model: example_bpe.model\ntrainer_interface.cc(699) LOG(INFO) Saving vocabs: example_bpe.vocab\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\nTrue\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n*** BPE ***\n['▁B', 'e', 'ginn', 'ers', '▁BBQ', '▁Cl', 'ass', '▁T', 'ak', 'ing', '▁P', 'la', 'ce', '▁in', '▁M', 'is', 's', 'ou', 'la', '!']\n```\n:::\n:::\n\n\n::: {#c77c0027 .cell execution_count=26}\n``` {.python .cell-code}\nshow_vocab(sp_vocab, end = ', ')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n▁B e g in n ers: 1, ▁BBQ: 3, ▁Cl ass: 2, ▁T ak ing: 1, ▁P la ce: 1, ▁in: 15, ▁M is s ou la !: 1, ▁D o: 1, ▁you: 13, ▁w an t: 1, ▁to: 33, ▁g et: 2, ▁be t ter: 2, ▁a t: 1, ▁mak ing: 2, ▁d e l ic i ou s: 1, ▁BBQ ?: 1, ▁ Y ou: 1, ▁will: 6, ▁have: 4, ▁the: 31, \n```\n:::\n:::\n\n\nOur implementation of BPE's code from the paper matches up pretty well with the library itself! Difference are probably accounted for by the `vocab_size`. There is also another technical difference in that in the SentencePiece implementation of BPE a priority queue is used to more efficiently keep track of the *best pairs*. Actually, there is a priority queue in the Python standard library called `heapq` if you would like to give that a try below! \n\n::: {#fbe56026 .cell execution_count=27}\n``` {.python .cell-code}\nfrom heapq import heappush, heappop\n```\n:::\n\n\n::: {#4ca69ca7 .cell execution_count=28}\n``` {.python .cell-code}\ndef heapsort(iterable):\n    h = []\n    for value in iterable:\n        heappush(h, value)\n    return [heappop(h) for i in range(len(h))]\n```\n:::\n\n\n::: {#b50b3b8a .cell execution_count=29}\n``` {.python .cell-code}\na = [1,4,3,1,3,2,1,4,2]\nheapsort(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n[1, 1, 1, 2, 2, 3, 3, 4, 4]\n```\n:::\n:::\n\n\nFor a more extensive example consider looking at the [SentencePiece repo](https://github.com/google/sentencepiece/blob/master/python/sentencepiece_python_module_example.ipynb). The last section of this code is repurposed from that tutorial. Thanks for your participation!\n\n",
    "supporting": [
      "lab01_files"
    ],
    "filters": [],
    "includes": {}
  }
}