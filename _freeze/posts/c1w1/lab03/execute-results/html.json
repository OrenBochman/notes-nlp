{
  "hash": "685a2f13bb0c9e321b4f5919d8b5b2f5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Visualizing tweets and the Logistic Regression model\njupyter: python3\ndate: 2020-10-23\ncategories: \n  - NLP \n  - Coursera \n  - lab\n  - Logistic regression\n  - Sentiment analysis task\n  - Classification & Vector Spaces\n---\n\n\n\n\n![course banner](/images/Course-Logo-1-3.webp){#fig-00 .column-margin .nolightbox}\n\n**Objectives:** Visualize and interpret the logistic regression model\n\n**Steps:**\n\n* Plot tweets in a scatter plot using their positive and negative sums.\n* Plot the output of the logistic regression model in the same plot as a solid line\n\n\n## Import the required libraries\n\nWe will be using [*NLTK*](http://www.nltk.org/howto/twitter.html), an opensource NLP library, for collecting, handling, and processing Twitter data. In this lab, we will use the example dataset that comes alongside with NLTK. This dataset has been manually annotated and serves to establish baselines for models quickly. \n\nSo, to start, let's import the required libraries. \n\n::: {#abe16fc3 .cell execution_count=2}\n``` {.python .cell-code}\nimport nltk                         # NLP toolbox\nfrom os import getcwd\nimport pandas as pd                 # Library for Dataframes \nfrom nltk.corpus import twitter_samples \nimport matplotlib.pyplot as plt     # Library for visualization\nimport numpy as np                  # Library for math functions\n\nfrom utils import process_tweet, build_freqs # Our functions for NLP\n```\n:::\n\n\n## Load the NLTK sample dataset\n\nTo complete this lab, you need the sample dataset of the previous lab. Here, we assume the files are already available, and we only need to load into Python lists.\n\n::: {#8f2b8a5d .cell execution_count=3}\n``` {.python .cell-code}\n# select the set of positive and negative tweets\nall_positive_tweets = twitter_samples.strings('positive_tweets.json')\nall_negative_tweets = twitter_samples.strings('negative_tweets.json')\n\ntweets = all_positive_tweets + all_negative_tweets ## Concatenate the lists. \nlabels = np.append(np.ones((len(all_positive_tweets),1)), np.zeros((len(all_negative_tweets),1)), axis = 0)\n\n# split the data into two pieces, one for training and one for testing (validation set) \ntrain_pos  = all_positive_tweets[:4000]\ntrain_neg  = all_negative_tweets[:4000]\n\ntrain_x = train_pos + train_neg \n\nprint(\"Number of tweets: \", len(train_x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of tweets:  8000\n```\n:::\n:::\n\n\n# Load the extracted features\n\nPart of this week's assignment is the creation of the numerical features needed for the Logistic regression model. In order not to interfere with it, we have previously calculated and stored these features in a CSV file for the entire training set.\n\nSo, please load these features created for the tweets sample. \n\n::: {#28f5ff87 .cell execution_count=4}\n``` {.python .cell-code}\ndata = pd.read_csv('logistic_features.csv'); # Load a 3 columns csv file using pandas function\ndata.head(10) # Print the first 10 data entries\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>bias</th>\n      <th>positive</th>\n      <th>negative</th>\n      <th>sentiment</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1.0</td>\n      <td>3020.0</td>\n      <td>61.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1.0</td>\n      <td>3573.0</td>\n      <td>444.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1.0</td>\n      <td>3005.0</td>\n      <td>115.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1.0</td>\n      <td>2862.0</td>\n      <td>4.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>1.0</td>\n      <td>3119.0</td>\n      <td>225.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>1.0</td>\n      <td>2955.0</td>\n      <td>119.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>1.0</td>\n      <td>3934.0</td>\n      <td>538.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>1.0</td>\n      <td>3162.0</td>\n      <td>276.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>1.0</td>\n      <td>628.0</td>\n      <td>189.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>1.0</td>\n      <td>264.0</td>\n      <td>112.0</td>\n      <td>1.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNow let us get rid of the data frame to keep only Numpy arrays.\n\n::: {#88960ccb .cell execution_count=5}\n``` {.python .cell-code}\n# Each feature is labeled as bias, positive and negative\nX = data[['bias', 'positive', 'negative']].values # Get only the numerical values of the dataframe\nY = data['sentiment'].values; # Put in Y the corresponding labels or sentiments\n\nprint(X.shape) # Print the shape of the X part\nprint(X) # Print some rows of X\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(8000, 3)\n[[1.000e+00 3.020e+03 6.100e+01]\n [1.000e+00 3.573e+03 4.440e+02]\n [1.000e+00 3.005e+03 1.150e+02]\n ...\n [1.000e+00 1.440e+02 7.830e+02]\n [1.000e+00 2.050e+02 3.890e+03]\n [1.000e+00 1.890e+02 3.974e+03]]\n```\n:::\n:::\n\n\n## Load a pretrained Logistic Regression model\n\nIn the same way, as part of this week's assignment, a Logistic regression model must be trained. The next cell contains the resulting model from such training. Notice that a list of 3 numeric values represents the whole model, that we have called _theta_ $\\theta$.\n\n::: {#9e3a452d .cell execution_count=6}\n``` {.python .cell-code}\ntheta = [7e-08, 0.0005239, -0.00055517]\n```\n:::\n\n\n## Plot the samples in a scatter plot\n\nThe vector theta represents a plane that split our feature space into two parts. Samples located over that plane are considered positive, and samples located under that plane are considered negative. Remember that we have a 3D feature space, i.e., each tweet is represented as a vector comprised of three values: `[bias, positive_sum, negative_sum]`, always having `bias = 1`. \n\nIf we ignore the bias term, we can plot each tweet in a cartesian plane, using `positive_sum` and `negative_sum`. In the cell below, we do precisely this. Additionally, we color each tweet, depending on its class. Positive tweets will be green and negative tweets will be red.\n\n::: {#3238c441 .cell execution_count=7}\n``` {.python .cell-code}\n# Plot the samples using columns 1 and 2 of the matrix\nfig, ax = plt.subplots(figsize = (8, 8))\n\ncolors = ['red', 'green']\n\n# Color based on the sentiment Y\nax.scatter(X[:,1], X[:,2], c=[colors[int(k)] for k in Y], s = 0.1)  # Plot a dot for each pair of words\nplt.xlabel(\"Positive\")\nplt.ylabel(\"Negative\")\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nText(0.5, 0, 'Positive')\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nText(0, 0.5, 'Negative')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](lab03_files/figure-html/cell-7-output-3.png){width=684 height=651}\n:::\n:::\n\n\nFrom the plot, it is evident that the features that we have chosen to represent tweets as numerical vectors allow an almost perfect separation between positive and negative tweets. So you can expect a very high accuracy for this model! \n\n## Plot the model alongside the data\n\nWe will draw a gray line to show the cutoff between the positive and negative regions. In other words, the gray line marks the line where $$ z = \\theta * x = 0.$$\nTo draw this line, we have to solve the above equation in terms of one of the independent variables.\n\n$$ z = \\theta * x = 0$$\n$$ x = [1, pos, neg] $$\n$$ z(\\theta, x) = \\theta_0+ \\theta_1 * pos + \\theta_2 * neg = 0 $$\n$$ neg = (-\\theta_0 - \\theta_1 * pos) / \\theta_2 $$\n\nThe red and green lines that point in the direction of the corresponding sentiment are calculated using a perpendicular line to the separation line calculated in the previous equations(neg function). It must point in the same direction as the derivative of the Logit function, but the magnitude may differ. It is only for a visual representation of the model. \n\n$$direction = pos * \\theta_2 / \\theta_1$$\n\n::: {#714d5a3d .cell execution_count=8}\n``` {.python .cell-code}\n# Equation for the separation plane\n# It give a value in the negative axe as a function of a positive value\n# f(pos, neg, W) = w0 + w1 * pos + w2 * neg = 0\n# s(pos, W) = (w0 - w1 * pos) / w2\ndef neg(theta, pos):\n    return (-theta[0] - pos * theta[1]) / theta[2]\n\n# Equation for the direction of the sentiments change\n# We don't care about the magnitude of the change. We are only interested \n# in the direction. So this direction is just a perpendicular function to the \n# separation plane\n# df(pos, W) = pos * w2 / w1\ndef direction(theta, pos):\n    return    pos * theta[2] / theta[1]\n```\n:::\n\n\nThe green line in the chart points in the direction where z > 0 and the red line points in the direction where z < 0. The direction of these lines are given by the weights $\\theta_1$ and $\\theta_2$\n\n::: {#fdac8790 .cell execution_count=9}\n``` {.python .cell-code}\n# Plot the samples using columns 1 and 2 of the matrix\nfig, ax = plt.subplots(figsize = (8, 8))\n\ncolors = ['red', 'green']\n\n# Color base on the sentiment Y\nax.scatter(X[:,1], X[:,2], c=[colors[int(k)] for k in Y], s = 0.1)  # Plot a dot for each pair of words\nplt.xlabel(\"Positive\")\nplt.ylabel(\"Negative\")\n\n# Now lets represent the logistic regression model in this chart. \nmaxpos = np.max(X[:,1])\n\noffset = 5000 # The pos value for the direction vectors origin\n\n# Plot a gray line that divides the 2 areas.\nax.plot([0,  maxpos], [neg(theta, 0),   neg(theta, maxpos)], color = 'gray') \n\n# Plot a green line pointing to the positive direction\nax.arrow(offset, neg(theta, offset), offset, direction(theta, offset), head_width=500, head_length=500, fc='g', ec='g')\n# Plot a red line pointing to the negative direction\nax.arrow(offset, neg(theta, offset), -offset, -direction(theta, offset), head_width=500, head_length=500, fc='r', ec='r')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nText(0.5, 0, 'Positive')\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nText(0, 0.5, 'Negative')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](lab03_files/figure-html/cell-9-output-3.png){width=684 height=651}\n:::\n:::\n\n\n**Note that more critical than the Logistic regression itself, are the features extracted from tweets that allow getting the right results in this exercise.**\n\nThat is all, folks. Hopefully, now you understand better what the Logistic regression model represents, and why it works that well for this specific problem. \n\n",
    "supporting": [
      "lab03_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}