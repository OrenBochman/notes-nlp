{
  "hash": "72fc4724245f9787876ed5a288e77e31",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Knights and Knaves world\"\nsubtitle: \"Inducing logic into an Emergent language\"\ndate: 2025-02-17\n---\n\n\n> \"if proof theory is about the sacred, then model theory is about the profane\"  -- [@van2012logic p.1]\n\n## Motivation\n\nIn the previous post, \"Further Desiderata for Emergent Language\", I discussed the need to adapt emerging languages to conform with established properties of natural languages. You can read more about motivations in that post. \n\nRather then considering all the ways this could be achieved in a single essay, I believe that this should be broken down and considered one aspect at a time. This can make both the linguistics and the development easier to understand.\n\nOnce enough examples are available it should become clearer on how to integrate the desiderata using suitable states or other mechanisms.\n\n## The task\n\nToday I want to consider the ability of language to encode logical reasoning. Logic is such a big field it can encampass all of mathematics and philosophy. So for this post we need to narrow things down.\n\nI'd like the agents not only to learn to speak in a langauge that captures logical reasoning, but also to be able to reason about states and statements made in that language.\n\nI am targeting reconstruction and discrimination games as\nthe inner game which is used to evolve the language. The frameing game might be drawn from \n\n1. Knights and Knaves puzzles\n2. Lewis Carroll's [The Game of Logic](https://en.wikipedia.org/wiki/The_Game_of_Logic) - for \n3. Jon Barwise and John Etchemendy created [Tarski's World](https://en.wikipedia.org/wiki/Tarski%27s_World) - for first order logic\n\n\n## Knights and Knaves worlds\n\nIn \"What Is the Name of This Book\" and his other works Raymond Smullyan use this as a framework to cover this puzzle to cover from propositional logic to the problem of undecidability...\n\nThe initial state is simple - each individual is either a knight or a knave. Knights always tell the truth, and knaves always lie.\n\nIn most puzzles we need to determine the type of each individual from a set of statements made by them.\n\nAnother type of variation is that we want to find out some fact about the world but must ask the right question to get the correct answer regardless of the individual's type.\n\nAnother variant that seems salient in this context is when the people in the puzzle respond in their own language, which is unkown to us. In this case we need to deduce the meaning of the words from the context.\n\nTo spice his puzzles up Smullyan introduced individuals that, who can lie or tell the truth as he pleases these might be called \"Normals\"\n\nIn his Transilvanian puzzles he introduced the notion that half the population are insane and have false beliefs e.g. that $2+2\\ne4$ and they are also devided into truthfull and lying types this time humans and vampires. In another book he introduced monkeys that look like humans. The only real difference was that monkeys have a tail and humans don't. In terms of logic it just add another collumn to the truth table for each individual.\n\n\nWe have for n individuals we have 2^n possible states.\n\nnext comes the creative part of the task we want to automate. The statements the individuals make. While each individual can make a statement tht reveals their ground truth we the idea is to \n\n1. ensure all the ground truths are revealed\n2. use a minimal number of statements (i.e. by omitting a statement the problem should be rendered unsolvable)\n3. ensure that the ground truths are unique\n\nIn the website https://christopherphelps.trinket.io/sites/knight_knave_puzzler the generator can be used to generate a number of statements:\n\n1. meta statements - is the puzzle solvable\n2. name calling - calling some one a knight or knave a normal a monkey, insane etc.\n3. Ascriptive statements - where an someone says what some type of individual would say about another speaker\n4. Prime statements- statements on the prime number of knights or knaves in the group\n5. independent statements - statements that don't seem to be related to the puzzle \n\n\nOne property of the puzzle is if no one makes a statement about an individual then his type is unconstrained and could be swapped without affecting the consistency of the puzzle.\n\n\n## How is logic encoded in the knights and knaves Puzzles?\n\nSo it is interesting to consider how one give a minimal general solution for such puzzles. In reality most puzzles do have\nshort solutions but in general when we consider logic and language we can't be certain that there is a neat solution or that \nthe puzlle has a unique answer or that the puzzle is solvable.\n\nSo here is a general approach to solve these puzzles using boolean logic:\n\n1. We encode all possible combinations of sub-states of the world using as inputs for a truth table. \nI.e. a column for each individual titled with their name and stating that they are a knight.\nWe don't need to encode the knave column as the two are mutually exclusive.\nIf there are other sub-states like being a monkey, insane, a spy we would need to add a column for these too.\n2. For each statement said we should rewrite it as a boolean expression in terms of these states.\n3. We need to verify the outcome of the statement for each combination of \n\nThen we encode the statements made by the individuals as a column in the truth table.\n\nlet's look at some examples with just knights and knaves\n\n### Name calling\n\n1. [ ] A says \"I am knave.\"    \n    - not possible for a knight (False) \n    - not possible for a knave (True)\n    - This will therefore not appear on it own. \n    - This will not be part of a conjunction made by a knight. i.e. \"and ...\"\n    - It can be used conjunction with a truthy statement made by a knave. ... and I am a knave\n2. [ ] A says \"I am knight.\"   \n    - if A is a knight (True)\n    - if A is a knave (False)\n3. A says \"B is a knave.\" \n    - if A is a knight and B is knave (True) \n    - if A is a knave and B is a knight (False)\n    note: that both types will call the other type a knave. so this only tells us the speaker is the same type as another individual.\n4. [ ] A says \"B is a knight.\" \n    - if A is a knight and B is a knight (True)\n    - if A is a knave and B is a knave  (False) \n5. [ ] A says \"I am the same type as B\"\n    same situation as #3\n6. [ ] A says \"B would say that I am a knave\" \n7. [ ] A says \"B would say that I am a knight\"\n8. There are a prime number of knaves in the group.\n9. There are a prime number of knights in the group.\n10. \"The puzzle is solvable\" means there isn't a contradiction in the statements made by the individuals. \n11. \"The puzzle is unsolvable\" means there is a contradiction in the statements made by the individuals.\n\n\n|A|B|A:#1|B:#1|\n|-|-|----|----|\n|1|1|0   |0   |\n|1|0|0   |1   |\n|0|1|1   |0   |\n|0|0|1   |1   |\n\n\n### Questions\n\n\n\n\n## Samurai world - Sub-States that imbue an emergent language with politeness and formality\n\nThis is a small state space which is used as a model^[in the sense of logic] for politeness and formality in natural language based on Japanese which has a more sophisticated system of politeness and formality then most languages.\n\nIn this game agents interact in a framing game.\nIn the lewis sub-game they need to coordinate a system in which they observe politeness and formality to avoid being decapitated by their superiors, yet avoid losing face, i.e. without being too polite or formal to their inferiors.\n\n\n- state:\n    - speaker's status \n        - gender, age, social status, relationship to subject\n    - subject's status\n \n\nOne could evolve the use of poltiness in a reconstruciton game or a discrimination game.\n\n- In the reconstruction task, Sender gets an input item, it sends a message to Receiver, and Receiver must generate an output item identical to Sender's input. \n- In the discrimination task, Sender gets an input item (the target); Receiver gets multiple input items (the same target and a number of distractors, in random order). \n\nNote that reconstruction is very much like the original lewis signaling game.\nWhile the discrimination easier task as the receiver could in theory fail to reconstruct, or have to choose at random from a very large, perhaps even infinite set of possible reconstructions and that having a jusk K distractorsit is down to 1/k probability of sucess. More so if it is equipped with the ability of learning from errors he might score the distractors and make progress with much higher information levels then in the reconstruction game.\n\n\n::: {.callout-info}\n## states for verbs and nouns\n\nOne issue is that there that I have not yet written up the states needed for differentiating between nouns and verbs. Not the states for creating inflected verbs. \n\nBoth of these are bigger tasks and I will need to write them up quickly. \n\nAnyhow is this case we should assume that there are already \n\n- nouns and verbs and possible other parts of speech.\n- verbs may be inflected.\n\nnow we wish to split certain verb states by adding sub-states that correspond to a politeness and formality flag.\n:::\n\n## Code \n\n\n\nHere is a data generation script that may be used with [@kharitonov:etal:2021] EGG emergence game toolkit to model politeness and formality in a multi-agent language game.\n\n::: {#be2265d1 .cell execution_count=1}\n``` {.python .cell-code}\nimport random\nimport numpy as np\n\n\nstate = dict()\n\ndef add_politenes_state(state):\n\n    state[\"speaker_status\"] = random.choice([\"0\", \"1\", \"2\", ])\n    state[\"subject_status\"] = random.choice([\"0\", \"1\", \"2\", ])\n    return state\n\nfor i in range(20):\n\n    state = dict()\n    state = add_politenes_state(state)\n    print(f\"{i},{state}\")\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0,{'speaker_status': '1', 'subject_status': '2'}\n1,{'speaker_status': '2', 'subject_status': '0'}\n2,{'speaker_status': '2', 'subject_status': '2'}\n3,{'speaker_status': '2', 'subject_status': '0'}\n4,{'speaker_status': '0', 'subject_status': '1'}\n5,{'speaker_status': '1', 'subject_status': '0'}\n6,{'speaker_status': '2', 'subject_status': '0'}\n7,{'speaker_status': '1', 'subject_status': '2'}\n8,{'speaker_status': '1', 'subject_status': '2'}\n9,{'speaker_status': '2', 'subject_status': '0'}\n10,{'speaker_status': '2', 'subject_status': '0'}\n11,{'speaker_status': '0', 'subject_status': '2'}\n12,{'speaker_status': '0', 'subject_status': '0'}\n13,{'speaker_status': '0', 'subject_status': '2'}\n14,{'speaker_status': '1', 'subject_status': '2'}\n15,{'speaker_status': '1', 'subject_status': '2'}\n16,{'speaker_status': '0', 'subject_status': '0'}\n17,{'speaker_status': '1', 'subject_status': '2'}\n18,{'speaker_status': '2', 'subject_status': '2'}\n19,{'speaker_status': '1', 'subject_status': '1'}\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}