{
  "hash": "1b17e34438c79133c41f89de71ae9862",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ndate: 2020-10-25\ntitle: \"Classes and subclasses\"\nsubtitle: \"Sequence Models\"\n#description: \"we cover Neural networks for deep learning, then build a tweet classifier that places tweets into positive or negative sentiment categories, using a DNN.\"\n\njupyter: python3\ncategories: \n  - NLP \n  - Coursera \n  - Lab\n  - Sequence Models\n  - Sentiment analysis task\n---\n\n\n\nIn this notebook, I will show you the basics of classes and subclasses in Python. As you've seen in the lectures from this week, `Trax` uses layer classes as building blocks for deep learning models, so it is important to understand how classes and subclasses behave in order to be able to build custom layers when needed. \n\nBy completing this notebook, you will:\n\n- Be able to define classes and subclasses in Python\n- Understand how inheritance works in subclasses\n- Be able to work with instances\n\n\n# Part 1: Parameters, methods and instances\n\nFirst, let's define a class `My_Class`. \n\n::: {#9c137c8f .cell execution_count=2}\n``` {.python .cell-code}\nclass My_Class: #Definition of My_class\n    x = None    \n```\n:::\n\n\n`My_Class`  has one parameter `x` without any value. You can think of parameters as the variables that every object assigned to a class will have. So, at this point, any object of class `My_Class` would have a variable `x` equal to `None`. To check this,  I'll create two instances of that class and get the value of `x` for both of them.\n\n::: {#a48b9c1e .cell execution_count=3}\n``` {.python .cell-code}\ninstance_a= My_Class() #To create an instance from class \"My_Class\" you have to call \"My_Class\"\ninstance_b= My_Class()\nprint('Parameter x of instance_a: ' + str(instance_a.x)) #To get a parameter 'x' from an instance 'a', write 'a.x'\nprint('Parameter x of instance_b: ' + str(instance_b.x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nParameter x of instance_a: None\nParameter x of instance_b: None\n```\n:::\n:::\n\n\nFor an existing instance you can assign new values for any of its parameters. In the next cell, assign a value of `5` to the parameter `x` of `instance_a`.\n\n::: {#4bd03b9a .cell execution_count=4}\n``` {.python .cell-code}\n### START CODE HERE (1 line) ### \ninstance_a.x = 5\n### END CODE HERE ###\nprint('Parameter x of instance_a: ' + str(instance_a.x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nParameter x of instance_a: 5\n```\n:::\n:::\n\n\n## 1.1 The `__init__` method\n\nWhen you want to assign values to the parameters of your class when an instance is created, it is necessary to define a special method: `__init__`. The `__init__` method is called when you create an instance of a class. It can have multiple arguments to initialize the paramenters of your instance. In the next cell I will define `My_Class` with an `__init__` method that takes the instance (`self`) and an argument `y` as inputs.\n\n::: {#eabc9453 .cell execution_count=5}\n``` {.python .cell-code}\nclass My_Class: \n    def __init__(self, y): # The __init__ method takes as input the instance to be initialized and a variable y\n        self.x = y         # Sets parameter x to be equal to y\n```\n:::\n\n\nIn this case, the parameter `x` of an instance from `My_Class` would take the value of an argument `y`. \nThe argument `self` is used to pass information from the instance being created to the method `__init__`. In the next cell, create an instance `instance_c`, with `x` equal to `10`.\n\n::: {#069a3331 .cell execution_count=6}\n``` {.python .cell-code}\n### START CODE HERE (1 line) ### \ninstance_c = My_Class(10)\n### END CODE HERE ###\nprint('Parameter x of instance_c: ' + str(instance_c.x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nParameter x of instance_c: 10\n```\n:::\n:::\n\n\nNote that in this case, you had to pass the argument `y` from the `__init__` method to create an instance of `My_Class`.\n\n## 1.2 The `__call__` method\n\nAnother important method is the `__call__` method. It is performed whenever you call an initialized instance of a class. It can have multiple arguments and you can define it to do whatever you want like\n\n- Change a parameter, \n- Print a message,\n- Create new variables, etc.\n\nIn the next cell, I'll define `My_Class` with the same `__init__` method as before and with a `__call__` method that adds `z` to parameter `x` and prints the result.\n\n::: {#c658089f .cell execution_count=7}\n``` {.python .cell-code}\nclass My_Class: \n    def __init__(self, y): # The __init__ method takes as input the instance to be initialized and a variable y\n        self.x = y         # Sets parameter x to be equal to y\n    def __call__(self, z): # __call__ method with self and z as arguments\n        self.x += z        # Adds z to parameter x when called \n        print(self.x)\n```\n:::\n\n\nLetâ€™s create `instance_d` with `x` equal to 5.\n\n::: {#e47ab971 .cell execution_count=8}\n``` {.python .cell-code}\ninstance_d = My_Class(5)\n```\n:::\n\n\nAnd now, see what happens when `instance_d` is called with argument `10`.\n\n::: {#7a4d7f76 .cell execution_count=9}\n``` {.python .cell-code}\ninstance_d(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n15\n```\n:::\n:::\n\n\nNow, you are ready to complete the following cell so any instance from `My_Class`:\n\n- Is initialized taking two arguments `y` and `z` and assigns them to `x_1` and `x_2`, respectively. And, \n- When called, takes the values of the parameters `x_1` and `x_2`, sums them, prints  and returns the result.\n\n::: {#4ebf0c54 .cell execution_count=10}\n``` {.python .cell-code}\nclass My_Class: \n    def __init__(self, y, z): #Initialization of x_1 and x_2 with arguments y and z\n        ### START CODE HERE (2 lines) ### \n        self.x_1 = y\n        self.x_2 = z\n        ### END CODE HERE ###\n    def __call__(self):       #When called, adds the values of parameters x_1 and x_2, prints and returns the result \n        ### START CODE HERE (1 line) ### \n        result = self.x_1 + self.x_2 \n        ### END CODE HERE ### \n        print(\"Addition of {} and {} is {}\".format(self.x_1,self.x_2,result))\n        return result\n```\n:::\n\n\nRun the next cell to check your implementation. If everything is correct, you shouldn't get any errors.\n\n::: {#624d384c .cell execution_count=11}\n``` {.python .cell-code}\ninstance_e = My_Class(10,15)\ndef test_class_definition():\n    \n    assert instance_e.x_1 == 10, \"Check the value assigned to x_1\"\n    assert instance_e.x_2 == 15, \"Check the value assigned to x_2\"\n    assert instance_e() == 25, \"Check the __call__ method\"\n    \n    print(\"\\033[92mAll tests passed!\")\n    \ntest_class_definition()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAddition of 10 and 15 is 25\nAll tests passed!\n```\n:::\n:::\n\n\n## 1.3 Custom methods\n\nIn addition to the `__init__` and `__call__` methods, your classes can have custom-built methods to do whatever you want when called. To define a custom method, you have to indicate its input arguments, the instructions that you want it to perform and the values to return (if any). In the next cell, `My_Class` is defined with `my_method` that multiplies the values of `x_1` and `x_2`, sums that product with an input `w`, and returns the result.\n\n::: {#5e313c88 .cell execution_count=12}\n``` {.python .cell-code}\nclass My_Class: \n    def __init__(self, y, z): #Initialization of x_1 and x_2 with arguments y and z\n        self.x_1 = y\n        self.x_2 = z\n    def __call__(self):       #Performs an operation with x_1 and x_2, and returns the result\n        a = self.x_1 - 2*self.x_2 \n        return a\n    def my_method(self, w):   #Multiplies x_1 and x_2, adds argument w and returns the result\n        result = self.x_1*self.x_2 + w\n        return result\n```\n:::\n\n\nCreate an instance `instance_f` of `My_Class` with any integer values that you want for `x_1` and `x_2`. For that instance, see the result of calling `My_method`, with an argument `w` equal to `16`.\n\n::: {#8e1bba20 .cell execution_count=13}\n``` {.python .cell-code}\n### START CODE HERE (1 line) ### \ninstance_f = My_Class(1,10)\n### END CODE HERE ### \nprint(\"Output of my_method:\",instance_f.my_method(16))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutput of my_method: 26\n```\n:::\n:::\n\n\nAs you can corroborate in the previous cell, to call a custom method `m`, with arguments `args`, for an instance `i` you must write `i.m(args)`. With that in mind, methods can call others within a class. In the following cell, try to define `new_method` which calls `my_method` with `v` as input argument. Try to do this on your own in the cell given below.\n\n::: {#439b47d0 .cell execution_count=14}\n``` {.python .cell-code}\nclass My_Class: \n    def __init__(self, y, z):         #Initialization of x_1 and x_2 with arguments y and z\n        self.x_1 = None\n        self.x_2 = None\n    def __call__(self):               #Performs an operation with x_1 and x_2, and returns the result\n        a = None \n        return a\n    def my_method(self, w):           #Multiplies x_1 and x_2, adds argument w and returns the result\n        b = None\n        return b\n    def new_method(self, v):          #Calls My_method with argument v\n        ### START CODE HERE (1 line) ### \n        result = None\n        ### END CODE HERE ### \n        return result\n```\n:::\n\n\n<b>SPOILER ALERT</b> Solution:\n\n::: {#61f205bd .cell execution_count=15}\n``` {.python .cell-code}\n# hidden-cell\nclass My_Class: \n    def __init__(self, y, z):      #Initialization of x_1 and x_2 with arguments y and z\n        self.x_1 = y\n        self.x_2 = z\n    def __call__(self):            #Performs an operation with x_1 and x_2, and returns the result\n        a = self.x_1 - 2*self.x_2 \n        return a\n    def my_method(self, w):        #Multiplies x_1 and x_2, adds argument w and returns the result\n        b = self.x_1*self.x_2 + w\n        return b\n    def new_method(self, v):       #Calls My_method with argument v\n        result = self.my_method(v)\n        return result\n```\n:::\n\n\n::: {#718ad3d4 .cell execution_count=16}\n``` {.python .cell-code}\ninstance_g = My_Class(1,10)\nprint(\"Output of my_method:\",instance_g.my_method(16))\nprint(\"Output of new_method:\",instance_g.new_method(16))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutput of my_method: 26\nOutput of new_method: 26\n```\n:::\n:::\n\n\n# Part 2: Subclasses and Inheritance\n\n`Trax` uses classes and subclasses to define layers. The base class in `Trax` is `layer`, which means that every layer from a deep learning model is defined as a subclass of the `layer` class. In this part of the notebook, you are going to see how subclasses work. To define a subclass `sub` from class `super`, you have to write `class sub(super):` and define any method and parameter that you want for your subclass. In the next cell, I define `sub_c` as a subclass of `My_Class` with only one method (`additional_method`).\n\n::: {#6c1cdce4 .cell execution_count=17}\n``` {.python .cell-code}\nclass sub_c(My_Class):           #Subclass sub_c from My_class\n    def additional_method(self): #Prints the value of parameter x_1\n        print(self.x_1)\n```\n:::\n\n\n## 2.1 Inheritance\n\nWhen you define a subclass `sub`, every method and parameter is inherited from `super` class, including the `__init__` and `__call__` methods. This means that any instance from `sub` can use the methods defined in `super`.  Run the following cell and see for yourself.\n\n::: {#495606e6 .cell execution_count=18}\n``` {.python .cell-code}\ninstance_sub_a = sub_c(1,10)\nprint('Parameter x_1 of instance_sub_a: ' + str(instance_sub_a.x_1))\nprint('Parameter x_2 of instance_sub_a: ' + str(instance_sub_a.x_2))\nprint(\"Output of my_method of instance_sub_a:\",instance_sub_a.my_method(16))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nParameter x_1 of instance_sub_a: 1\nParameter x_2 of instance_sub_a: 10\nOutput of my_method of instance_sub_a: 26\n```\n:::\n:::\n\n\nAs you can see, `sub_c` does not have an initialization method `__init__`, it is inherited from `My_class`. However, you can overwrite any method you want by defining it again in the subclass. For instance, in the next cell define a class `sub_c` with a redefined `my_Method` that multiplies `x_1` and `x_2` but does not add any additional argument.\n\n::: {#869849ea .cell execution_count=19}\n``` {.python .cell-code}\nclass sub_c(My_Class):           #Subclass sub_c from My_class\n    def my_method(self):         #Multiplies x_1 and x_2 and returns the result\n        ### START CODE HERE (1 line) ###\n        b = self.x_1*self.x_2 \n        ### END CODE HERE ###\n        return b\n```\n:::\n\n\nTo check your implementation run the following cell.\n\n::: {#8b664b15 .cell execution_count=20}\n``` {.python .cell-code}\ntest = sub_c(3,10)\nassert test.my_method() == 30, \"The method my_method should return the product between x_1 and x_2\"\n\nprint(\"Output of overridden my_method of test:\",test.my_method()) #notice we didn't pass any parameter to call my_method\n#print(\"Output of overridden my_method of test:\",test.my_method(16)) #try to see what happens if you call it with 1 argument\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutput of overridden my_method of test: 30\n```\n:::\n:::\n\n\nIn the next cell, two instances are created, one of `My_Class` and another one of `sub_c`. The instances are initialized with equal `x_1` and `x_2` parameters.\n\n::: {#39665999 .cell execution_count=21}\n``` {.python .cell-code}\ny,z= 1,10\ninstance_sub_a = sub_c(y,z)\ninstance_a = My_Class(y,z)\nprint('My_method for an instance of sub_c returns: ' + str(instance_sub_a.my_method()))\nprint('My_method for an instance of My_Class returns: ' + str(instance_a.my_method(10)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMy_method for an instance of sub_c returns: 10\nMy_method for an instance of My_Class returns: 20\n```\n:::\n:::\n\n\nAs you can see, even though `sub_c` is a subclass from `My_Class` and both instances are initialized with the same values, `My_method` returns different results for each instance because you overwrote `My_method` for `sub_c`.\n\n<b>Congratulations!</b> You just reviewed the basics behind classes and subclasses. Now you can define your own classes and subclasses, work with instances and overwrite inherited methods. The concepts within this notebook are more than enough to understand how layers in `Trax` work.\n\n",
    "supporting": [
      "lab02_files"
    ],
    "filters": [],
    "includes": {}
  }
}