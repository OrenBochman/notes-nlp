{
  "hash": "c2159a21cbb0a2328648583084baf4f6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Linear algebra in Python with NumPy\njupyter: python3\ncategories: \n  - NLP \n  - Coursera \n  - Lab\n  - Logistic regression\n  - Sentiment analysis task\n  - Classification & Vector Spaces\n# execute: \n#     error: true\n#cache: false\n---\n\n\n\n\n![course banner](/images/Course-Logo-1-3.webp){#fig-00 .column-margin .nolightbox}\n\nIn this lab, you will have the opportunity to remember some basic concepts about linear algebra and how to use them in Python.\n\nNumpy is one of the most used libraries in Python for arrays manipulation. It adds to Python a set of functions that allows us to operate on large multidimensional arrays with just a few lines. So forget about writing nested loops for adding matrices! With NumPy, this is as simple as adding numbers.\n\nLet us import the `numpy` library and assign the alias `np` for it. We will follow this convention in almost every notebook in this course, and you'll see this in many resources outside this course as well.\n\n::: {#637f8a6b .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np  # The swiss knife of the data scientist.\n```\n:::\n\n\n## Defining lists and numpy arrays\n\n::: {#fd368938 .cell execution_count=3}\n``` {.python .cell-code}\nalist = [1, 2, 3, 4, 5]   # Define a python list. It looks like an np array\nnarray = np.array([1, 2, 3, 4]) # Define a numpy array\n```\n:::\n\n\nNote the difference between a Python list and a NumPy array.\n\n::: {#ee09e801 .cell execution_count=4}\n``` {.python .cell-code}\nprint(alist)\nprint(narray)\n\nprint(type(alist))\nprint(type(narray))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5]\n[1 2 3 4]\n<class 'list'>\n<class 'numpy.ndarray'>\n```\n:::\n:::\n\n\n## Algebraic operators on NumPy arrays vs. Python lists\n\nOne of the common beginner mistakes is to mix up the concepts of NumPy arrays and Python lists. Just observe the next example, where we add two objects of the two mentioned types. Note that the '+' operator on NumPy arrays perform an element-wise addition, while the same operation on Python lists results in a list concatenation. Be careful while coding. Knowing this can save many headaches.\n\n::: {#021c80cf .cell execution_count=5}\n``` {.python .cell-code}\nprint(narray + narray)\nprint(alist + alist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2 4 6 8]\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\n```\n:::\n:::\n\n\nIt is the same as with the product operator, `*`. In the first case, we scale the vector, while in the second case, we concatenate three times the same list.\n\n::: {#82fe9bae .cell execution_count=6}\n``` {.python .cell-code}\nprint(narray * 3)\nprint(alist * 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 3  6  9 12]\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\n```\n:::\n:::\n\n\nBe aware of the difference because, within the same function,  both types of arrays can appear. \nNumpy arrays are designed for numerical and matrix operations, while lists are for more general purposes.\n\n## Matrix or Array of Arrays\n\nIn linear algebra, a matrix is a structure composed of n rows by m columns. That means each row must have the same number of columns. With NumPy, we have two ways to create a matrix:\n* Creating an array of arrays using `np.array` (recommended). \n* Creating a matrix using `np.matrix` (still available but might be removed soon).\n\nNumPy arrays or lists can be used to initialize a matrix, but the resulting matrix will be composed of NumPy arrays only.\n\n::: {#4a05d202 .cell execution_count=7}\n``` {.python .cell-code}\nnpmatrix1 = np.array([narray, narray, narray]) # Matrix initialized with NumPy arrays\nnpmatrix2 = np.array([alist, alist, alist]) # Matrix initialized with lists\nnpmatrix3 = np.array([narray, [1, 1, 1, 1], narray]) # Matrix initialized with both types\n\nprint(npmatrix1)\nprint(npmatrix2)\nprint(npmatrix3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2 3 4]\n [1 2 3 4]\n [1 2 3 4]]\n[[1 2 3 4 5]\n [1 2 3 4 5]\n [1 2 3 4 5]]\n[[1 2 3 4]\n [1 1 1 1]\n [1 2 3 4]]\n```\n:::\n:::\n\n\nHowever, when defining a matrix, be sure that all the rows contain the same number of elements. Otherwise, the linear algebra operations could lead to unexpected results.\n\nAnalyze the following two examples:\n\n::: {#bcab497b .cell execution_count=8}\n``` {.python .cell-code}\n# Example 1:\n\nokmatrix = np.array([[1, 2], [3, 4]]) # Define a 2x2 matrix\nprint(okmatrix) # Print okmatrix\nprint(okmatrix * 2) # Print a scaled version of okmatrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2]\n [3 4]]\n[[2 4]\n [6 8]]\n```\n:::\n:::\n\n\n::: {#4e3973f8 .cell execution_count=9}\n``` {.python .cell-code}\n# Example 2:\n\nbadmatrix = np.array([[1, 2], [3, 4], [5, 6, 7]]) # Define a matrix. Note the third row contains 3 elements\nprint(badmatrix) # Print the malformed matrix\nprint(badmatrix * 2) # It is supposed to scale the whole matrix\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">ValueError</span>                                Traceback (most recent call last)\nCell <span class=\"ansi-green-fg\">In[47], line 3</span>\n<span class=\"ansi-green-fg ansi-bold\">      1</span> <span style=\"font-style:italic;color:rgb(95,135,135)\"># Example 2:</span>\n<span class=\"ansi-green-fg\">----&gt; 3</span> badmatrix <span style=\"color:rgb(98,98,98)\">=</span> <span class=\"ansi-yellow-bg\">np</span><span style=\"color:rgb(98,98,98)\" class=\"ansi-yellow-bg\">.</span><span class=\"ansi-yellow-bg\">array</span><span class=\"ansi-yellow-bg\">(</span><span class=\"ansi-yellow-bg\">[</span><span class=\"ansi-yellow-bg\">[</span><span style=\"color:rgb(98,98,98)\" class=\"ansi-yellow-bg\">1</span><span class=\"ansi-yellow-bg\">,</span><span class=\"ansi-yellow-bg\"> </span><span style=\"color:rgb(98,98,98)\" class=\"ansi-yellow-bg\">2</span><span class=\"ansi-yellow-bg\">]</span><span class=\"ansi-yellow-bg\">,</span><span class=\"ansi-yellow-bg\"> </span><span class=\"ansi-yellow-bg\">[</span><span style=\"color:rgb(98,98,98)\" class=\"ansi-yellow-bg\">3</span><span class=\"ansi-yellow-bg\">,</span><span class=\"ansi-yellow-bg\"> </span><span style=\"color:rgb(98,98,98)\" class=\"ansi-yellow-bg\">4</span><span class=\"ansi-yellow-bg\">]</span><span class=\"ansi-yellow-bg\">,</span><span class=\"ansi-yellow-bg\"> </span><span class=\"ansi-yellow-bg\">[</span><span style=\"color:rgb(98,98,98)\" class=\"ansi-yellow-bg\">5</span><span class=\"ansi-yellow-bg\">,</span><span class=\"ansi-yellow-bg\"> </span><span style=\"color:rgb(98,98,98)\" class=\"ansi-yellow-bg\">6</span><span class=\"ansi-yellow-bg\">,</span><span class=\"ansi-yellow-bg\"> </span><span style=\"color:rgb(98,98,98)\" class=\"ansi-yellow-bg\">7</span><span class=\"ansi-yellow-bg\">]</span><span class=\"ansi-yellow-bg\">]</span><span class=\"ansi-yellow-bg\">)</span> <span style=\"font-style:italic;color:rgb(95,135,135)\"># Define a matrix. Note the third row contains 3 elements</span>\n<span class=\"ansi-green-fg ansi-bold\">      4</span> <span style=\"color:rgb(0,135,0)\">print</span>(badmatrix) <span style=\"font-style:italic;color:rgb(95,135,135)\"># Print the malformed matrix</span>\n<span class=\"ansi-green-fg ansi-bold\">      5</span> <span style=\"color:rgb(0,135,0)\">print</span>(badmatrix <span style=\"color:rgb(98,98,98)\">*</span> <span style=\"color:rgb(98,98,98)\">2</span>) <span style=\"font-style:italic;color:rgb(95,135,135)\"># It is supposed to scale the whole matrix</span>\n\n<span class=\"ansi-red-fg\">ValueError</span>: setting an array element with a sequence. The requested array has an inhomogeneous shape after 1 dimensions. The detected shape was (3,) + inhomogeneous part.</pre>\n```\n:::\n\n:::\n:::\n\n\n## Scaling and translating matrices\n\nNow that you know how to build correct NumPy arrays and matrices, let us see how easy it is to operate with them in Python using the regular algebraic operators like + and -. \n\nOperations can be performed between arrays and arrays or between arrays and scalars.\n\n::: {#144540f6 .cell execution_count=10}\n``` {.python .cell-code}\n# Scale by 2 and translate 1 unit the matrix\nresult = okmatrix * 2 + 1 # For each element in the matrix, multiply by 2 and add 1\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[3 5]\n [7 9]]\n```\n:::\n:::\n\n\n::: {#f27c7b14 .cell execution_count=11}\n``` {.python .cell-code}\n# Add two compatible matrices\nresult1 = okmatrix + okmatrix\nprint(result1)\n\n# Subtract two compatible matrices. This is called the difference vector\nresult2 = okmatrix - okmatrix\nprint(result2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[2 4]\n [6 8]]\n[[0 0]\n [0 0]]\n```\n:::\n:::\n\n\nThe product operator `*` when used on arrays or matrices indicates element-wise multiplications.\nDo not confuse it with the dot product.\n\n::: {#5d62d618 .cell execution_count=12}\n``` {.python .cell-code}\nresult = okmatrix * okmatrix # Multiply each element by itself\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 1  4]\n [ 9 16]]\n```\n:::\n:::\n\n\n## Transpose a matrix\n\nIn linear algebra, the transpose of a matrix is an operator that flips a matrix over its diagonal, i.e., the transpose operator switches the row and column indices of the matrix producing another matrix. If the original matrix dimension is n by m, the resulting transposed matrix will be m by n.\n\n**T** denotes the transpose operations with NumPy matrices.\n\n::: {#afeea4e5 .cell execution_count=13}\n``` {.python .cell-code}\nmatrix3x2 = np.array([[1, 2], [3, 4], [5, 6]]) # Define a 3x2 matrix\nprint('Original matrix 3 x 2')\nprint(matrix3x2)\nprint('Transposed matrix 2 x 3')\nprint(matrix3x2.T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal matrix 3 x 2\n[[1 2]\n [3 4]\n [5 6]]\nTransposed matrix 2 x 3\n[[1 3 5]\n [2 4 6]]\n```\n:::\n:::\n\n\nHowever, note that the transpose operation does not affect 1D arrays.\n\n::: {#02a96f10 .cell execution_count=14}\n``` {.python .cell-code}\nnparray = np.array([1, 2, 3, 4]) # Define an array\nprint('Original array')\nprint(nparray)\nprint('Transposed array')\nprint(nparray.T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal array\n[1 2 3 4]\nTransposed array\n[1 2 3 4]\n```\n:::\n:::\n\n\nperhaps in this case you wanted to do:\n\n::: {#26bf8c77 .cell execution_count=15}\n``` {.python .cell-code}\nnparray = np.array([[1, 2, 3, 4]]) # Define a 1 x 4 matrix. Note the 2 level of square brackets\nprint('Original array')\nprint(nparray)\nprint('Transposed array')\nprint(nparray.T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal array\n[[1 2 3 4]]\nTransposed array\n[[1]\n [2]\n [3]\n [4]]\n```\n:::\n:::\n\n\n## Get the norm of a nparray or matrix\n\nIn linear algebra, the norm of an n-dimensional vector $\\vec a$   is defined as:\n\n$$ norm(\\vec a) = ||\\vec a|| = \\sqrt {\\sum_{i=1}^{n} a_i ^ 2}$$\n\nCalculating the norm of vector or even of a matrix is a general operation when dealing with data. Numpy has a set of functions for linear algebra in the subpackage **linalg**, including the **norm** function. Let us see how to get the norm a given array or matrix:\n\n::: {#18f0f9fa .cell execution_count=16}\n``` {.python .cell-code}\nnparray1 = np.array([1, 2, 3, 4]) # Define an array\nnorm1 = np.linalg.norm(nparray1)\n\nnparray2 = np.array([[1, 2], [3, 4]]) # Define a 2 x 2 matrix. Note the 2 level of square brackets\nnorm2 = np.linalg.norm(nparray2) \n\nprint(norm1)\nprint(norm2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5.477225575051661\n5.477225575051661\n```\n:::\n:::\n\n\nNote that without any other parameter, the norm function treats the matrix as being just an array of numbers.\nHowever, it is possible to get the norm by rows or by columns. The **axis** parameter controls the form of the operation: \n* **axis=0** means get the norm of each column\n* **axis=1** means get the norm of each row. \n\n::: {#2e1db3b6 .cell execution_count=17}\n``` {.python .cell-code}\nnparray2 = np.array([[1, 1], [2, 2], [3, 3]]) # Define a 3 x 2 matrix. \n\nnormByCols = np.linalg.norm(nparray2, axis=0) # Get the norm for each column. Returns 2 elements\nnormByRows = np.linalg.norm(nparray2, axis=1) # get the norm for each row. Returns 3 elements\n\nprint(normByCols)\nprint(normByRows)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[3.74165739 3.74165739]\n[1.41421356 2.82842712 4.24264069]\n```\n:::\n:::\n\n\nHowever, there are more ways to get the norm of a matrix in Python.\nFor that, let us see all the different ways of defining the dot product between 2 arrays.\n\n## The dot product between arrays: All the flavors\n\nThe dot product or scalar product or inner product between two vectors $\\vec a$ and $\\vec b$ of the same size is defined as:\n$$\\vec a \\cdot \\vec b = \\sum_{i=1}^{n} a_i b_i$$\n\nThe dot product takes two vectors and returns a single number.\n\n::: {#e8e84499 .cell execution_count=18}\n``` {.python .cell-code}\nnparray1 = np.array([0, 1, 2, 3]) # Define an array\nnparray2 = np.array([4, 5, 6, 7]) # Define an array\n\nflavor1 = np.dot(nparray1, nparray2) # Recommended way\nprint(flavor1)\n\nflavor2 = np.sum(nparray1 * nparray2) # Ok way\nprint(flavor2)\n\nflavor3 = nparray1 @ nparray2         # Geeks way\nprint(flavor3)\n\n# As you never should do:             # Noobs way\nflavor4 = 0\nfor a, b in zip(nparray1, nparray2):\n    flavor4 += a * b\n    \nprint(flavor4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n38\n38\n38\n38\n```\n:::\n:::\n\n\n**We strongly recommend using np.dot, since it is the only method that accepts arrays and lists without problems**\n\n::: {#0c3ef828 .cell execution_count=19}\n``` {.python .cell-code}\nnorm1 = np.dot(np.array([1, 2]), np.array([3, 4])) # Dot product on nparrays\nnorm2 = np.dot([1, 2], [3, 4]) # Dot product on python lists\n\nprint(norm1, '=', norm2 )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n11 = 11\n```\n:::\n:::\n\n\nFinally, note that the norm is the square root of the dot product of the vector with itself. That gives many options to write that function:\n\n$$ norm(\\vec a) = ||\\vec a|| = \\sqrt {\\sum_{i=1}^{n} a_i ^ 2} = \\sqrt {a \\cdot a}$$\n\n## Sums by rows or columns\n\nAnother general operation performed on matrices is the sum by rows or columns.\nJust as we did for the function norm, the **axis** parameter controls the form of the operation:\n* **axis=0** means to sum the elements of each column together. \n* **axis=1** means to sum the elements of each row together.\n\n::: {#f5fc6d50 .cell execution_count=20}\n``` {.python .cell-code}\nnparray2 = np.array([[1, -1], [2, -2], [3, -3]]) # Define a 3 x 2 matrix. \n\nsumByCols = np.sum(nparray2, axis=0) # Get the sum for each column. Returns 2 elements\nsumByRows = np.sum(nparray2, axis=1) # get the sum for each row. Returns 3 elements\n\nprint('Sum by columns: ')\nprint(sumByCols)\nprint('Sum by rows:')\nprint(sumByRows)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSum by columns: \n[ 6 -6]\nSum by rows:\n[0 0 0]\n```\n:::\n:::\n\n\n## Get the mean by rows or columns\n\nAs with the sums, one can get the **mean** by rows or columns using the **axis** parameter. Just remember that the mean is the sum of the elements divided by the length of the vector\n$$ mean(\\vec a) = \\frac {{\\sum_{i=1}^{n} a_i }}{n}$$\n\n::: {#12e65d29 .cell execution_count=21}\n``` {.python .cell-code}\nnparray2 = np.array([[1, -1], [2, -2], [3, -3]]) # Define a 3 x 2 matrix. Chosen to be a matrix with 0 mean\n\nmean = np.mean(nparray2) # Get the mean for the whole matrix\nmeanByCols = np.mean(nparray2, axis=0) # Get the mean for each column. Returns 2 elements\nmeanByRows = np.mean(nparray2, axis=1) # get the mean for each row. Returns 3 elements\n\nprint('Matrix mean: ')\nprint(mean)\nprint('Mean by columns: ')\nprint(meanByCols)\nprint('Mean by rows:')\nprint(meanByRows)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMatrix mean: \n0.0\nMean by columns: \n[ 2. -2.]\nMean by rows:\n[0. 0. 0.]\n```\n:::\n:::\n\n\n## Center the columns of a matrix\n\nCentering the attributes of a data matrix is another essential preprocessing step. Centering a matrix means to remove the column mean to each element inside the column. The mean by columns of a centered matrix is always 0.\n\nWith NumPy, this process is as simple as this:\n\n::: {#10689eb4 .cell execution_count=22}\n``` {.python .cell-code}\nnparray2 = np.array([[1, 1], [2, 2], [3, 3]]) # Define a 3 x 2 matrix. \n\nnparrayCentered = nparray2 - np.mean(nparray2, axis=0) # Remove the mean for each column\n\nprint('Original matrix')\nprint(nparray2)\nprint('Centered by columns matrix')\nprint(nparrayCentered)\n\nprint('New mean by column')\nprint(nparrayCentered.mean(axis=0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal matrix\n[[1 1]\n [2 2]\n [3 3]]\nCentered by columns matrix\n[[-1. -1.]\n [ 0.  0.]\n [ 1.  1.]]\nNew mean by column\n[0. 0.]\n```\n:::\n:::\n\n\n**Warning:** This process does not apply for row centering. In such cases, consider transposing the matrix, centering by columns, and then transpose back the result. \n\nSee the example below:\n\n::: {#1bfb63da .cell execution_count=23}\n``` {.python .cell-code}\nnparray2 = np.array([[1, 3], [2, 4], [3, 5]]) # Define a 3 x 2 matrix. \n\nnparrayCentered = nparray2.T - np.mean(nparray2, axis=1) # Remove the mean for each row\nnparrayCentered = nparrayCentered.T # Transpose back the result\n\nprint('Original matrix')\nprint(nparray2)\nprint('Centered by rows matrix')\nprint(nparrayCentered)\n\nprint('New mean by rows')\nprint(nparrayCentered.mean(axis=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal matrix\n[[1 3]\n [2 4]\n [3 5]]\nCentered by rows matrix\n[[-1.  1.]\n [-1.  1.]\n [-1.  1.]]\nNew mean by rows\n[0. 0. 0.]\n```\n:::\n:::\n\n\nNote that some operations can be performed using static functions like `np.sum()` or `np.mean()`, or by using the inner functions of the array\n\n::: {#f539b1fe .cell execution_count=24}\n``` {.python .cell-code}\nnparray2 = np.array([[1, 3], [2, 4], [3, 5]]) # Define a 3 x 2 matrix. \n\nmean1 = np.mean(nparray2) # Static way\nmean2 = nparray2.mean()   # Dinamic way\n\nprint(mean1, ' == ', mean2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3.0  ==  3.0\n```\n:::\n:::\n\n\nEven if they are equivalent, we recommend the use of the static way always.\n\n**Congratulations! You have successfully reviewed vector and matrix operations with Numpy!**\n\n",
    "supporting": [
      "lab01_files"
    ],
    "filters": [],
    "includes": {}
  }
}