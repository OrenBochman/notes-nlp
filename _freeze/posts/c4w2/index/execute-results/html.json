{
  "hash": "7c61848528f80e02aa32e69d7b069856",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ndate: 2021-03-31\ntitle: Week 2 Text Summarization\nsubtitle: NLP with Attention Models\ndescription: \"This week of the NLP Specialization, we unlock the secrets of Neural Text Summarization. We will building a powerful Transformer model to extract crucial information and create concise summaries. Through hands-on exercises using JAX, we will learn techniques like beam search and length normalization to enhance the quality of our summaries. Through hands-on exercises we will train our model on a dataset of articles. We will master the skills to create effective text summaries using state-of-the-art NLP techniques.\"\ncategories: \n  - Attention Models\n  - Neural Machine Translation\n  - Coursera \n  - notes\n  - Deep Learning Algorithms\n  - transformer\n  - teacher forcing\n  - positional encoding\n  - GPT2\n  - transformer decoder\n  - attention\n  - dot product attention\n  - self attention\n  - causal attention\n  - multi-head attention\n  - summarization task\nimage: img/notes-formulas.jpg\n---\n\n\n![deeplearning.ai](img/course-banner.jpg){.column-margin}\n\n<!-- vale off -->\n<!-- vale on --> \n\n- I immersed myself in this material so I could real understand it.\n- I treated the assignments like small work or research project thinking how they could be made better and more rigorous.\n- I been interested in summarization task for many years.\n\n::: {.callout-note}\n## Learning objectives\n\n<!-- TODO: add links to repective sections -->\n- [x] Describe the three basic types of attention.\n- [x] Name the two types of layers in a Transformer.\n- [x] Define three main matrices in attention.\n- [x] Interpret the math behind scaled dot product attention, causal attention, and multi-head attention.\n- [x] Use articles and their summaries to create input features for training a text summarizer.\n- [x] Build the GPT-2 transformer-decoder model.\n:::\n\n\n\n::: {.callout-tip collapse=false}\n## TL;DR neural network engineering\n<!-- TODO: better summary -->\n\nFor the impatient  - We'll start with  NLP engineering insights from this week.\n\n<!-- TODO: add podcast for this week's material -->\n:::\n\n\n### What is attention ?\n\nThe latest version of {{ site.product_name }} is now available.\n- Attention is a general solution for the sequence alignment problem.\n- Attention doesn't reorder the input sequence.\n- It provides a linear transformation which filters the relevant parts of the source for predicting the each item in the target.\n\n$$\nattention(h_t,\\bar{h}_s)= softmax(h_t^T\\bar{h}_s)\n$$\n\n### What is dot-product attention ?\n\n- Dot Product attention is the most common form of attention.\n- In the engineering sense it is suited for a encoder-decoder architecture \n- It is the best fit for tasks where the source sequence is fully available at the start and the tasks is mapping or transformation the source sequence to an output sequence like \n- It is used for alignment and machine translation or translation.\n\n$$\nattention_{(\\cdot)}(Q,V,K) = softmax(\\frac{QK^T}{\\sqrt{n}})V\n$$  \n\n::: {#c4da4924 .cell execution_count=1}\n``` {.python .cell-code}\ndef DotProductAttention(query,key,value,mask,scale=True):\n    \"\"\"Dot product self-attention.\n    Args:\n        scale (bool): if to scale \n    Returns:\n        numpy.ndarray: attention array (L_q by L_k)\n    \"\"\"\n    # Save query embedding dimension\n    depth = query.shape[-1] if scale else 1\n    # Calculate scaled query key dot product \n    dots = np.matmul(query, np.swapaxes(key, -1, -2)) / np.sqrt(depth) \n    # Apply the mask\n    if mask is not None:\n        dots = np.where(mask, dots, np.full_like(dots, -1e9)) \n    logsumexp = scipy.special.logsumexp(dots, axis=-1, keepdims=True)\n    dots = np.exp(dots - logsumexp)\n    attention = np.matmul(dots, value)\n    return attention\n```\n:::\n\n\n### What is causal attention ?\n\n- Causal attention is also called *self attention*.\n- It is used to generate a sequence based on previous tokens.\n- It requires a mask $M$ to enforce ignoring 'future' values during training.\n\n$$ \nattention_{self}(Q,V,K) = softmax(\\frac{QK^T}{\\sqrt{n}}+M)V\n$$\n\nwhere:\n\n- $n$ is the embedding dimension.\n\n```python\ndef SelfAttention(query,key,value,scale=True):\n    \"\"\"Self attention.\n    Args:\n        scale (bool): if to scale \n    Returns:\n        numpy.ndarray: Self-attention array (L_q by L_k)\n    \"\"\"\n    # Save query embedding dimension\n    depth = query.shape[-1] if scale else 1\n    # Calculate scaled query key dot product \n    dots = np.matmul(query, np.swapaxes(key, -1, -2)) / np.sqrt(depth) \n    logsumexp = scipy.special.logsumexp(dots, axis=-1, keepdims=True)\n    dots = np.exp(dots - logsumexp)\n    attention = np.matmul(dots, value)\n    return attention\n```\n\n### What is multi-headed attention?\n\nMulti-headed attention replicates the attention mechanism analogously to the multiple filters used in convolutional layers.\n  \n$$\nattention_{mh}(Q,V,K) = softmax(\\frac{QK^T}{\\sqrt{n}})V\n$$\n\nThe different attention heads are given different subspaces of the embeddings to work with. This causes them to specialize on different areas. More so if the embedding is also structured to store different data in subspaces say by concatenating different embeddings for morphology, semantics etc in those sub spaces.\n\nAfter input is processed by the heads their output is concatenated and processed by a big feed forward layer which uses most of the parameters in the model. \n\n### What is positional encoding\n\nUnlike the RNN which process information sequentially transforms need to provide the model with extra information to explicitly describe the order if the input sequences. \n\nYou might think this is added as an index but positional embedding is added as a low dimensional wave which can be added to an high dimensional embedding. (or concatenated)\nthis is achieved using a special purpose layer.\n\n```python\nimport trax\nimport trax.layers as tl\n\n# Embedding inputs and positional encoder\npositional_encoder = [ \n    # Add embedding layer of dimension (vocab_size, d_model)\n    tl.Embedding(vocab_size, d_model),\n    # Use dropout with rate and mode specified\n    tl.Dropout(rate=dropout,mode=mode),\n    # Add positional encoding layer with maximum input length and mode specified\n    tl.PositionalEncoding(max_len=max_len)\n]\n```\n### What is teacher forcing ?\n\n> An interesting technique that is frequently used in dynamical supervised learning tasks is to replace the actual output y(t) of a unit by the teacher signal d(t) in subsequent computation of the behavior of the network, whenever such a value exists. We call this technique teacher forcing.\n>— [A Learning Algorithm for Continually Running Fully Recurrent Neural Networks, 1989](http://ieeexplore.ieee.org/document/6795228/).\n\n## Additional coding notes:\n\nHere are some notable code snippets. \n\n### How to reshape a test tensor so it has a (size 0) batch dimension at the front?\n\nThis is needed when inspecting single test inputs instead of working with a batch. The model is expecting to process batches of inputs like it saw during training - we therefore need to add a dimension at the start.\n\n```python\npadded_with_batch = fastnp.expand_dims(fastnp.array(padded),axis=0)\n\n# get log probabilities from the last token output\nlog_probs = output[0,-1,:] \n```\n\n### How to make TRAX take in string date as a stream ?\n\n```python\ninputs =  next(trax.data.tokenize(iter([input_str]),\n                vocab_dir='vocab_dir/',\n                vocab_file='summarize32k.subword.subwords'))\n```\n\n### How to transpose batched tensors ?\n\n```python\n  # batch_size, seqlen, n_heads, d_head -> batch_size, n_heads, seqlen, d_head\n  x = jnp.transpose(x, (0, 2, 1, 3))\n```\n\n### How to de-structure tensors for use with multihead attention ?\n\n```python\n  # batch_size, seqlen, n_heads*d_head -> batch_size, seqlen, n_heads, d_head\n  x = jnp.reshape(x,(batch_size, seqlen, n_heads, d_head))\n  # batch_size, seqlen, n_heads, d_head -> batch_size, n_heads, seqlen, d_head\n  x = jnp.transpose(x, (0, 2, 1, 3))\n  # batch_size, n_heads, seqlen, d_head -> batch_size*n_heads, seqlen, d_head\n  x = jnp.reshape(x,( batch_size*n_heads, seqlen, d_head))\n```\n\n<pre>\ninput tensor shape: (3, 2, 6)\n[[[1 0 0 1 0 0]\n  [0 1 0 0 1 0]]\n [[1 0 0 1 0 0]\n  [0 1 0 0 1 0]]\n [[1 0 0 1 0 0]\n  [0 1 0 0 1 0]]]\noutput tensor shape: (6, 2, 3)\n[[[1 0 0]\n  [0 1 0]]\n [[1 0 0]\n  [0 1 0]]\n [[1 0 0]\n  [0 1 0]]\n [[1 0 0]\n  [0 1 0]]\n [[1 0 0]\n  [0 1 0]]\n [[1 0 0]\n  [0 1 0]]]\n</pre>\n\n## Video 1: Transformers vs RNNs\n\nRNNs were a big breakthrough and became the state of the art (SOTA) for machine translation (MT).\n\nThis illustrates a typical RNN that is used to translate the English sentence \"How are you?\" to its German equivalent, \"Wie sind Sie?\".\n\n![rnn-non-parallel](img/c4w2-04-rnn-non-parallel.png){.column-margin}\n\n![lstm](img/c4w2-10-lstm.png){.column-margin}\n\nThe LSTM which goes a long way to solving the vanishing gradient problems requires three times the memory and cpu steps a the vanilla RNN.\n\nHowever, as time went by and models got longer and deeper the biggest challenge with improving RNNs, became  their use of sequential computation. \n\n![seq2seq-steps](img/c4w2-11-seq2seq-steps.png){.column-margin}\n\nWhich entailed that to process the word \"you\", the RNN it has to first go through \"are\" and then \"you\". \nTwo other issues with RNNs are the:\n\n### Information loss \n\nIt becomes harder to keep track of whether the subject is singular or plural as you move further away from the subject.\n\n\n![Transformer](img/c4w2-12-transformer.png){.column-margin}\n\ntransformer architecture:\n\nin the encoder side \n- lookup layer - \n  the source sequence is converted from one hot encoding to a distributed representation using an embedding.\n- this is converted to K V matrices\nin the decoder side\n\n### Vanishing Gradient\n\nWhen gradients you back-propagate, the gradients can become really small and as a result.\n\nWith small gradient the model will learn very little.\n \n![positional-encoding](img/c4w2-14-positonal-encoding.png){.column-margin}\n \nTransformers which are based on attention and don't require any sequential computation per layer, only a single step is needed. \n\n![summary](img/c4w2-13-summary.png){.column-margin}\n\nAdditionally, the gradient steps that need to be taken from the last output to the first input in a transformer is just one. \nFor RNNs, the number of steps increases with longer sequences. Finally, transformers don't suffer from vanishing gradients problems that are related to the length of the sequences. \n\n## Video 2: Transformer Applications\n\n![application](img/c4w2-15-application.png){.column-margin}\nTransformers have essentially replaced RNN,LSTM and GRUs in sequence processing.\n\n![application-NLP](img/c4w2-16-application-NLP.png){.column-margin}\n\n### Applications:\n\n- Text summarization\n- Autocomplete\n- NER\n- Q&A\n- Translation\n- Chat Bots\n- Sentiment Analyses\n- Market Intelligence\n- Text Classification\n- OCR\n- Spell Checking\n\n![sota](img/c4w2-17-sota.png){.column-margin}\n\n### SOTA Transformers\n\nTransformers Time Line:\n\n   -  GPT-4: \n   -  ElmO\n   -  BERT \n   -  T5  \n\n## T5 - Text-To-Text Transfer Transformer\n\n![t5](img/c4w2-18-t5.gif){.column-margin}\n\n![t5](img/c4w2-18-t5.png){.column-margin}\n\n[@DBLP:journals/corr/abs-1910-10683] introduced T5 which can do a number of tasks with a single model. While the earlier transformer models were able to score high in many different tasks without specific training. T5 is setup to handle different inputs and respond with output that is relevant to the requested task.\n\n### T5 Classification tasks  \n\nThese tasks are selected using the initial string:\n- Translate English into German\n- Cola sentence\n- Question\n\n![text-to-text-transformer](img/c4w2-19-text-to-text-transformer.png){.column-margin}\n\n### T5 regression tasks\n\n- Stbs Sentence1 ... Stbs Sentence2 ...\n- Summarize: \n\n[play trivia against T5 here](https://t5-trivia.glitch.me/)\n\n![transformers quiz](img/c4w2-21-quiz.png){.column-margin}\n\n::: {.callout-warning}\nI found this one a little confusing\n:::\n\nWe are told that the transformers can do in one operation what RNN needed to do in many steps. Also when querying transformers it does one task at a time. It seem that this question is about the ability of multiple heads to do several tasks at once could not do this is not well understood. \n\n![summary of transformers](img/c4w2-20-summary-of-transformers.png){.column-margin}\n\n\n## Video 3: Dot-Product Attention\n\n![outline-of-dot-product-attention](img/c4w2-22-outline-of-dot-product-attention.png){.column-margin}\n\nDot product attention was introduced in 2015 by *Minh-Thang Luong, Hieu Pham, Christopher D. Manning* in [Effective Approaches to Attention-based Neural Machine Translation](https://arxiv.org/pdf/1508.04025v5.pdf) which is available at [papers with code](https://paperswithcode.com/paper/effective-approaches-to-attention-based).\n\nLook at [Review of Effective Approaches to Attention-based NMT](2021-03-21-review-of-effective-approaches-to-attention-based-neural-machine-translation)\n\nDot product attention is the main operation in transformers. It is the dot product between the embedding of source and target sequences. The embedding used is a cross language embedding in which distance between equivalent across languages are minimized. This facilitates finding the cosine similarity using the dot product between words.\n\n![intro-to-attention](img/c4w2-23-intro-to-attention.png){.column-margin}\n\nLet's try to understand *dot product attention* intuitively by walking over its operations at the word level. The actual algorithm  uses linear algebra to perform many operations at once which is fast but more abstract and therefore difficult to understand.\n\n1. Using a pre-trained  **cross-language** embedding encode:\n   - each German word vector $q_i$ is placed as a column vector to form the query matrix $Q$,\n   - each English word once as $k_i$ and once as $v_i$, column vectors in the key $K$ and value $V$ matrices. This is more of a preprocessing step.\n1. For each German word we want to derive a continuous filter function on the English sequence to pick the most relevant words for translation. We build this filter for word $q_i$ by taking its dot product $q_i \\cdot k_i$ with every word vector from the english sequence these products are called the the attention weights.\n1. next we convert the rudimentary filter to a probabilistic one by applying a $softmax()$ which is just a differentiable function that converts the *attention weights* to *probabilities* by keeping them at the same relative sizes while ensuring they add to one.\n1. now that we have a $q$-filter we want to apply it. This is done by taking the weighed sum of the english words using the attention weights. \n\n$$\n\\hat q_i = \\sum_{i} softmax(q_i \\cdot k_i) \\times v_i =  \\sum w_a(q_i) * v_i \n$$ \n\n\n### Query, Key & Value\n\n![queries-keys-values](img/c4w2-24-queries-keys-values.png){.column-margin}\n\nAttention uses three matrices which are formed as shown in the figure The **Query** $Q$, **Key** $K$ and **Value** $V$ are formed from the source and target (if there is no target then just from the source). Each word is converted into an embedding column vector and these are placed into the matracies as their columns. \nIn the master class embedded bellow Dr. Łukasz Kaiser talks about attention and here he is talking about solving the problem of retrieving information from a long sequence. At around 16 minutes in he call Q a query vector and K and V a memory, of all the words we have seen, which we want to access.\n\n- The ***Q**uery* is the matrix formed from the column word vector for the German words. \n- The ***K**ey* is the matrix formed from the column word vector for the English words. \n- The ***V**alue* is the matrix formed from the column word vector for the English words.\n\n::: {.callout-note}\nK and V are the same\n:::\n\nOnce these are called keys since we use them to are we doing a similarity lookup. And the second time they are called value because we use them in the activation when we apply the weights to them. The input and output sequences are mapped to an embedding layer to become the $Q$, $K$ and $V$ matrices. \n\n\n{{< video https://www.youtube.com/embed/rBCqOTEfxvg >}}\n\n\nGiven an input, you transform it into a new representation or a column vector. Depending on the task you are working on, you will end up getting queries, keys, and values. Each column corresponds to a word in the figure above. Hence, when you compute the following: \n\n![attention-formula](img/c4w2-26-dot-product-attention-math.png){.column-margin}\n\n1. multiply $Q$ by $V$.\n1. apply the $softmax()$ to transform to a probability.\n1. multiply the softmax by $V$\n\n\n![attention-math](img/c4w2-26-attention-math.png){.column-margin}\n\nThis is restating the above in a very confusing way. I looked at it many times before I figured out that the square brackets are the dimensions and that we have the following two formulas indicated schematically above:\n\n$$\nZ = W_A V \n$$\n\nwhere:\n\n- Z has size of is a 'Q length' $\\times$ 'Embedding size' matrix \n- or for coders $[len(Q),D]$ dimensional array \n\n$$\nW_A = softmax(QK^T)\n$$\n\nThis concept implies that similar vectors are likely to have a higher score when you dot them with one another. You transform that score into a probability by using a softmax function. You can then multiply the output by \n\nYou can think of the **keys** and the **values** as being the same. Note that both $K$,$V$ are of dimension $L_k, D$. Each query $q_i$ picks the most similar key $k_j$.\n\n![attention-formula](img/c4w2-27-attention-formula.png){.column-margin}\n\nQueries are the German words and the keys are the English words. Once you have the attention weights, you can just multiply it by $V$ to get a weighted combination of the input. \n\n![attention-quiz](img/c4w2-28-attention-quizz.png){.column-margin}\n\n![summary-for-dot-product-attention](img/c4w2-29-summary-for-dot-product-attention.png){.column-margin}\n\nanother interesting point made in the preceding talk is that dot product attention has $O(n^2 *d)$ complexity but typically $d >> n$ since $d ~ 1000$ while for $n ~ 70$. So transformers should perform better then an RNN whose complexity is $O(n*d^2)$. And this is before the advantages of using an efficient transformer like reformer.\n \nIn [@DBLP:journals/corr/abs-2103-13076] there is a reversal of the trend from rnn to transformers. Here  the latest results show a an idea of training big transformers and then converting them to RNN to improve performance. (One get an RNN by training a transformer.)\n\n\n## V4: Causal Attention\n\n- We are interested in three main types of attention. \n- We'll see a brief overview of causal attention. \n- We'll discover some mathematical foundations behind the causal attention. \n\n\n![three forms of attention](img/c4w2-30-three-ways-of-attention.png){.column-margin}\n\nIn terms of use cases there are three types of attention mechanisms:\n\n\n### Scaled dot product attention:\n\n  - AKA Encoder-Decoder attention.\n  - one sentence in the decoder look at to another one in the encoder.\n  - use cases:\n    - seq2seq\n    - machine translation.\n\n### Causal Attention:\n\n  - AKA self attention.\n  - attention is all you need.\n  - In the same sentence words attend to previous words. \n  - Future words have not been generated yet. \n  - use cases:\n    - generation \n    - text generation \n    - summarization.\n  \n### Bi-directional self attention:\n\n  - In one sentence words look both at previous and future words.\n  - use cases:\n    - machine comprehension.\n    - question answering\n\n![causal attention](img/c4w2-31-causal-attention.png){.column-margin}\n\nIn causal attention, **queries** and **keys** come from the same sentence. That is why it is often referred to as **self-attention**.  In general, causal attention allows words to attend to other words that are related in various ways. \n\n![causal attention mask](img/c4w2-32-causal-attention-mask.png){.column-margin}\n\nAt a high-level We have K Q V matrices.  corresponding \nHowever, token should not attend to words in the future since these were not generated yet.\nTherefore the future token's data is masked by adding a big negative number.\n\n\n![causal-attention-math-](img/c4w2-33-causal-attention-math-.png){.column-margin}\n \nMathematically, it looks like this: \n\n![causal-attention-quiz](img/c4w2-34-causal-attention-quiz.png){.column-margin}\n\n![summary-for-causal-attention](img/c4w2-35-summary-for-causal-attention.png){.column-margin}\n\n## V5: Multi-head Attention\n\n![outline-of-muti-head-attention](img/c4w2-40-outline-of-mutihead-attention.png){.column-margin}\nLet's summarize the intuition behind **multi-head attention** and **scaled dot product attention**.\n\n![muti-head-attention](img/c4w2-41-muti-head-attention.png){.column-margin}\n\nQ. What are multiple attention heads?\n\n- Multiple attention heads are simply replicas of the attention mechanism. In this they are analogous to the multiple filters used in a convolutional neural networks (CNN). \n- During training they specialize by learning different relationships between words.\n- During inference the operate parallel and independently of each other.\n  \n\n![overview of muti-head attention](img/c4w2-42-overview-of-muti-head-attention.png){.column-margin}\n\nThis is perhaps the most important slide - but it fails to show the critical part of the algorithm.\n\nLet's suppose we have $k$ attention heads. We see at the lowest level the $K$, $Q$ and $V$ being passed into passing through k linear layers. How is this accomplished and more important why. What is actually happening here is the opposite of concatenation. Instead of processing a query embedding from a space of $d$-dimensions we first split the embedding into $k$ vectors of length $D/k$. We have now k vectors from a k $D/k$-dimensional subspace. We now perform a dot product attention on each of these subspaces.\n\n<!-- place here a better image of the splitting mechanism ! -->\n\nEach of these dot product attention is operating on a difference subspace. It sees different subsets of the data and therefore specializes. How do these heads specializes is anybody's guess - unless we have a special embedding which has been processed using PCA or some other algorithm to ensure that each subspace corresponds to some interpretable subset of features.\n\n![muti-head attention scaled dot-product](img/c4w2-43-muti-head-attention-scaled-dot-product.png){.column-margin}\n\nFor example if we used a 1024 dimension embedding which concatenates 4 representations.\n\n1. [0:256] is an embedding trained on a *phonological* task\n2. [256:512] is an embedding trained on a *morphological* task\n3. [513:768] is an embedding trained on a *syntactical* task\n4. [769:1024] is an embedding trained on a *semantic* task\n\nWe could devise a number of subspace sampling schemes to give the k different attention heads different areas of specializations.\n\n1. sample from a single sub-space\n1. 4 heads sample from one subspace and 4 heads sample from 3 different sub-spaces\n1. 5 heads sampling from 2 subspaces different sub-spaces and 3 from 1\n1. 5 heads sampling from 2 subspaces different sub-spaces and 3 from three\n\nEach would specialize on a domain or on a interface between two domain or on all data but one domain.\nLanguage is rather redundant so they may be able to reconstruct most of the missing data - but at least they would specialize in a linguistically meaningful way.\n\nGiven a word, you take its embedding then you multiply it by the $Q$, $K$, $V$ matrix to get the corresponding queries, keys and values. When you use multi-head attention, a head can learn different relationships between words from another head. \n\nHere's one way to look at it: \n\n-  First, imagine that you have an embedding for a word. You multiply that embedding with $Q$ to get $q_1$, $K$ to get $k_1$, and V to get $v_1$\n\n\n![muti-head-attention-concatenation](img/c4w2-44-muti-head-attention-concatenation.png){.column-margin}\n\n![muti-head-attention-math](img/c4w2-46-muti-head-attention-math.png){.column-margin}\n\n![muti-head-attention-fotmula](img/c4w2-47-muti-head-attention-fotmula.png){.column-margin}\n\n\n![muti-head-attention-quiz](img/c4w2-48-muti-head-attention-quiz.png){.column-margin}\n\n![muti-head-attention-math](img/c4w2-50-muti-head-attention-math.png){.column-margin}\n\n![muti-head-attention-math](img/c4w2-51-muti-head-attention-math.png){.column-margin}\n\n![muti-head-attention-math](img/c4w2-52-muti-head-attention-math.png){.column-margin}\n\n![muti-head-attention-math](img/c4w2-53-muti-head-attention-math.png){.column-margin}\n\n- Next, you feed it to the linear layer, once you go through the linear layer for each word, you need to calculate a score. After that, you end up having an embedding for each word. But you still need to get the score for how much of each word you are going to use. For example, this will tell you how similar two words are $q_1$ and $k_1$or even $q_1$ and $k_2$  by doing a simple $q_1 \\dot k_1$. You can take the softmax of those scores (the paper mentions that you have to divide by $\\sqrt(d)$ to get a probability and then you multiply that by the value. That gives you the new representation of the word.)\nIf you have many heads, you can concatenate them and then multiply again by a matrix that is of dimension (dim of each head by num heads - dim of each head) to get one final vector corresponding to each word. \n\nHere is step by step guide, first you get the $Q$, $K$, $V$ matrices: \nNote that the computation above was done for one head. If you have several heads, concretely nn, then you will have $Z_1, Z_2, \\ldots, Z_n$. In which case, you can just concatenate them and multiply by a $W_O$ matrix as follows:\n\nHence, the more heads you have, the more $Z$s you will end up concatenating and as a result, that will change the inner dimension of $W_O$, which will then project the combined embeddings into one final embedding. \n\n![summary-muti-head-attention](img/c4w2-49-summary-muti-head-attention.png){.column-margin}\n\n## V6: Transformer Decoder\n\n![outline](img/c4w2-60-outline.png){.column-margin}\n\nThere is a learning objective here!\n\nthe transformer decoder has two parts \n\n- a decoder block (with multi-head attention) - think feature acquisition.\n- a feed forward block  - think non-parametric regression on the features.\n\n\n![transformer-decoder-overview](img/c4w2-62-transformer-decoder-overview.png){.column-margin}\n\n![transformer-decoder-explaination](img/c4w2-63-transformer-decoder-explaination.png){.column-margin}\n\n![transformer-decoder-ff](img/c4w2-64-transformer-decoder-ff.png){.column-margin}\n\n![transformer-decoder-explaination](img/c4w2-65-transformer-decoder-explaination.png){.column-margin}\n\n![transformer-decoder-summary](img/c4w2-68-transformer-decoder-summary.png){.column-margin}\n\n\n# V7: Transformer Summarizer\n\n![outline](img/c4w2-70-outline.png){.column-margin}\n\nIn this video we move on from attention and transformer blocks to the actual nlp task of text summarization. I noticed that the assignment put most of the focus on the coding of attention and the transformer block. Once it worked I started to really wonder what was going on under the hood and realized that while the notebooks it said we were building this from scratch, the reality was that `trax` framework was hiding lots of the implementation details from us\n\n![transformer-for-summarization](img/c4w2-71-transformer-for-summarization.png){.column-margin}\nwe are told there is an input and an output but the two are combined into one long sequence.\n\n![loss-weights](img/c4w2-72-loss-weights.png){.column-margin}\nSo to account for concatenating the output to the output we have a mask.\n\nHowever we might want to give the input some weights so that we can incorporate it into the language model.\nalso I don't think I saw anywhere how we feed this loss weighs into the loss function.\nLoss weights were created as a masks by the following code:\n\n```python\n  mask = [0] * (len(list(article)) + 2) + [1] * (len(list(summary)) + 1) \n  # the +2 Accounting for EOS and SEP\n  # and +1 Accounting for the final EOS \n```\n\n![cost-function](img/c4w2-73-cost-function.png){.column-margin}\n\n## Cross entropy loss \n\nCross-entropy loss, or log loss, measures the performance of a classification model whose output is a probability value between 0 and 1. Cross-entropy loss increases as the predicted probability diverges from the actual label.\n\n![inference](img/c4w2-74-inference.png){.column-margin}\n\nAfter training GPT2 on summarization data we just treat it like a word model and mine it for summaries. We do this by supply it with an input and predicting the output token by token. \nA more sophisticated method might be to use a beam search. \n\nAn even more sophisticated method might be to use an information metric to reject sentences and back track or better yet to do negative sampling from the prediction distribution (i.e. erase some prediction's probabilities and renormalize)\n\nOne could do even better by providing hints, especially if we also head some kind of extractive model with a high-level of certainty about the most important sentence and their most significant concepts.\n\n![quiz](img/c4w2-76-quiz.png){.column-margin}\n\nWe want the model to be penalized if it makes the wrong prediction. In this case it it does not predict the next word in the summary.\n\nThis may not be ideal for a number of reasons:\n\n1. the **Big world view**  *\"we are interested in a summary not the next word\"* what if the model is generating a semantically equivalent summary, in such a case it should not be penalized at all.\n\nIn a previous assignment we used a **siamese network** to check if two queries were equivalent. I think that allowing the network would be beneficial. (A loss that examines a generated sequence and compares it to the output.) But I don't really know how to back-propagate the outcome for all the words. Well not exactly\n\nAs we are using **teacher forcing** we can take a position that we ignore all the mistakes the model made and give it a good output sequence and ask it for the next word. This then allows us to back prop the last word's loss all by itself.\n\nIf we do this for each word in the output in sequence we should be able to reuse most of the calculations.\n\nThere are cases we have multiple summaries:\n\n- For a wikipedia article we often have all version from  inception to the current day. This can provide multiple summaries and text along with an a golden version (the current summary). Oh and we may have a better summary in other languages but that is a different story.\n- For IMDB movie plots we often have a long synopsis and multiple shorter summaries. Also we may also have the book or screen play.\n\nI mention these two cases since [Curriculum Learning](https://towardsdatascience.com/how-to-improve-your-network-performance-by-using-curriculum-learning-3471705efab4) may be able to assist us in training\n\n![summary](img/c4w2-75-summary.png){.column-margin}\n\nI think these is much missing from this lesson about summerization. However there are a number of good source in papers as well as some lectures on YouTube.\n\nI have quickly summarized one and should link to it from [here]() once it is published.\n\n\n## Lab1 : Attention\n\nThis was a numpy based realization of dot product and multi-head attention.\nSome of the main assignment required porting this to Jax.\n\n## Lab2 : The Transformer Decoder\n\nthis covered the transformer block\n\n## Assignment: Transformer Summarizer\n\nThis long assignment primarily focused on dot product attention,  multi-head attention and on building the transformer blocks. These were manageable as their theory had been explained in the lectures and their code had already been covered in the labs. It glosses over the parts involving data processing, training, evaluation and the actual summarization task. The summarization is accomplished using maximum likelihood estimate. A beam search might have yielded better results.\n\nThe date as described by:\n\n> We use the CNN/Daily Mail dataset (Hermann et al., 2015; Nallapati et al., 2016), which contains online news articles (781 tokens on average) paired with multi-sentence summaries (3.75 sentences or 56 tokens on average). \n\n>  [Get To The Point §4 (Abigail et all 2017) ](https://arxiv.org/pdf/1704.04368.pdf)\nWe used the non anatomized version. However the earlier paper used a preprocessed version which replaced the named entities with token like `$entity5`. This is probably ideal in other situations like event processing where each event looks quite different unless one anatomizes them rendering them much more similar and hopefully helping the model generalize better by learning from the partitions induced by the equivalency relation. \n\n## Expanding the lab to a project:\n\nThis is one of the main areas I'd like to focus on for a project. I have in mind a tool for improving wikipedia article leads. Here is how I'd like to take this project to the next level:\n\n### more data\n\ntrain it on additional material:\n\n- papers and abstracts. \n- wikipedia articles (with good first paragraphs. )\n- books and book summaries (could be problematic due to the book's length)\n- movie scripts and outlines from IMDB\n    - a Storyline\n    - summary (paragraph)\n    - a synopsis (longer)\n\n### More algorithms\n\n- Using a reformer to handle longer texts like books.\n- Better summarization using: \n  - a **beam search** to build better summaries.\n  - a **bayesian search** to avoid repetitions.\n- use curriculum learning to speed up training with \n  - easier examples first.\n  - multiple summaries per text.\n  - learning on anonymized NE before graduating to non-anonymized texts\n- use better method for evaluation of summary. \n  - Perhaps an `f-score` combining *precision* or *recall* on\n  - Attention Activation summed as a Coverage score for each token.\n- use of non zero loss-weights layer\n  - drop to zero as training progresses.\n  - depend on the actual length of source and output.\n  - use [tf-idf](https://en.wikipedia.org/wiki/Tf%E2%80%93idf) to make holes in the mask surrounding essential concepts.\n\n### Evaluation\n\nuse sammy lib with\n\n- rouge-n metric\n- the pyramid metric\n\n### Extra features \n\n  - [ ] pages for paper reviews\n  - [ ] pages for research questions\n  - [ ] pages to implement exra code/ experiments.\n- [ ] visualize the concepts/sentences/paragraphs/sections covered in the summary.\n- [ ] establish a hierarchy of what would go into a longer outline.\n- [ ] develop a f-score metric combining precision and recall for the summary of the abstract.\n- [ ] in academic writing one sentence per paragraphs should capture the main concept and it is generally the first second or the last. Is such a sentence is available identify it. This would be done by comparing each sentence with the rest of the paragraph.\n\n## Open question\n\nFor me the assignment raised a number of questions about what really going on here during training.\n\nI'll probably do this assignment again and look for some answers to my many questions. Once I have these I'll add them in the body of these notes.\n\n### Questions\n\n\n1. Loading and prepocessing the data:\n   1. What is going on after we load the dataset - is there data augmentation?\n   1. What this sub word vocab?\n   1. How to make my own sub word vocab?\n   1. How are out of vocab words being handled?\n   1. Can we query the model about these beside running decode ?\n   1. How are these created - I saw several sizes of vocab.\n1. Training\n   1. Training data seems to be a little mangled - there seems to be missing white space after the first token of the summaries, is there some way to fix this?\n   1. In not sure but why do we use teacher forcing during training?\n   - It should speed training up, but the setup is unclear.\n1. Evaluation\n   1. Why are we not looking at a summarization metic like pyramid, rouge5 or good old precision and recall.\n1. Inference\n   1. How can we tell the model thinks its done?\n   - when it output and <eof> token\n   1. How to generate one sentence for each paragraph/section \n   - Chop up the input and summarise each section.\n   - Create an new dataset that bases it summaries on the last and first sentences of each paragraph. \n      If that's too long summarize again for each section.\n   - Introduce a timed mask that hides [0:t*len/T] where T is total number of tokens being generated.\n   - make the mask a Bayesian search mechanism that hides concepts in the output.\n   1. How to use multiple summaries like in IMDB?\n   - score using the pyramid scheme or rogue.\n   1. How to make the model avoid repeating /rephrasing themselves?\n   - use a metric on new information. for example Maximal marginal relevance. \n     $MMR = \\argmax [\\lambda Sim_1(s_i,Q)- (1 - \\lambda) \\max Sim_2(s_i,s_j)]$\n     where $Q$ is the query and $s$ are output sentences\n     and try to bake this into the regularization.\n   - a coverage vector seems to be a recommend method.\n1. Visualization\n  - Is there a easy way to see the activation for each word in the output?\n  - Is there a easy way to see which concepts are significant (not too common and not too rare)\n  - Is there a easy way to see which concepts are salient - aligned to near by concepts.\n\n## References\n\n## Papers\n\n### Transformers\n\n1. [Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer] (Raffel et al, 2019)  \n1. [Reformer: The Efficient Transformer] (Kitaev et al, 2020)\n1. [Attention Is All You Need] (Vaswani et al, 2017)\n1. [Deep contextualized word representations] (Peters et al, 2018)\n1. [BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding] (Devlin et al, 2018)\n1. [Finetuning Pretrained Transformers into RNNs] (Kasai et all 2021)\n\n### Summarization\n\n1. [A trainable document summarizer. (Kupiec et al., 1995)](http://www.csie.ntnu.edu.tw/~g96470318/A_trainable_document_summarizer_.pdf) extractive\n1. [Constructing literature abstracts by computer: techniques and prospects. (Paice, 1990)]() extractive\n1. [Automatic text summarization: Past, present and future (Saggion and Poibeau, 2013)](https://hal.archives-ouvertes.fr/hal-00782442/document) extractive\n1. [Abstractive sentence summarization with attentive recurrent neural networks. (Chopra et al., 2016)](https://www.aclweb.org/anthology/N16-1012.pdf) abstractive summarization \n1. [Pointing the unknown words. (Nallapati et al., 2016)](https://arxiv.org/pdf/1603.08148.pdf) abstractive summarization \n1. [A neural attention model for abstractive sentence summarization. (Rush et al.,2015;)](https://arxiv.org/pdf/1509.00685.pdf) abstractive summarization \n1. [Efficient summarization with read-again and copy mechanism(Zeng et al., 2016)](https://arxiv.org/pdf/1509.00685.pdf) abstractive summarization \n1. [Get To The Point: Summarization with Pointer-Generator Networks (Abigail et all 2017)](https://arxiv.org/pdf/1704.04368.pdf) Hybrid summarization. Note: **Christopher D. Manning**\n1. [Extractive Summarization as Text Matching (Zhong et all 2020)](https://arxiv.org/pdf/2004.08795v1.pdf)\n\n## Articles\n\n1. [The Illustrated Transformer] (Alammar, 2018)\n1. [The Illustrated GPT-2] (Alammar, 2019)\n1. [How GPT3 Works - Visualizations and Animations] (Alammar, 2020)\n1. [Attention? Attention!] (Lilian Weng, 2018)\n1. [The Transformer Family] (Lilian Weng, 2020)\n1. [Teacher forcing for RNNs](https://machinelearningmastery.com/teacher-forcing-for-recurrent-neural-networks/)\n\n## Links\n\n- [Jax](https://github.com/google/jax)\n- [Trax](https://trax-ml.readthedocs.io/en/latest/index.html)\n- [Trax community](https://gitter.im/trax-ml/community) on Gitter\n- [CNN daily mail dataset](https://github.com/abisee/cnn-dailymail)\n\n<!-- \n# all images\nformat all image names like\n/assets/week2/c4w2-04-name.png\nrun search and replace:\n^(assets/week2/c4w2-..-)([^.]+)(\\.png)\n![$2](img//$1$2$3){.column-margin}\n to get them as images get all the names\n-->\n\n## References \n\n[Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer]: https://arxiv.org/abs/1910.10683\n[Reformer: The Efficient Transformer]: https://arxiv.org/abs/2001.04451\n[Attention Is All You Need]: https://arxiv.org/abs/1706.03762 \n[Deep contextualized word representations]: https://arxiv.org/pdf/1802.05365.pdf\n[The Illustrated Transformer]: http://jalammar.github.io/illustrated-transformer/\n[The Illustrated GPT-2]: http://jalammar.github.io/illustrated-gpt2/\n[BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding]: https://arxiv.org/abs/1810.04805\n[How GPT3 Works - Visualizations and Animations]: http://jalammar.github.io/how-gpt3-works-visualizations-animations/\n[Attention? Attention!]: https://lilianweng.github.io/lil-log/2018/06/24/attention-attention.html (Lilian Weng, 2018)\n[The Transformer Family]: https://lilianweng.github.io/lil-log/2020/04/07/the-transformer-family.html \"(Lilian Weng, 2020)\"\n[Finetuning Pretrained Transformers into RNNs]: https://arxiv.org/abs/2103.13076 \"(Kasai et all 2021)\"\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}