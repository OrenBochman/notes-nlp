{
  "hash": "d46c92f596274e191a097eb81f8edd2d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'The Three Ways of Attention and Dot Product Attention: Ungraded Lab Notebook'\njupyter: python3\n---\n\n\n\n\n\nIn this notebook you'll explore the three ways of attention (encoder-decoder attention, causal attention, and bi-directional self attention) and how to implement the latter two with dot product attention. \n\n## Background\n\nAs you learned last week, **attention models** constitute powerful tools in the NLP practitioner's toolkit. Like LSTMs, they learn which words are most important to phrases, sentences, paragraphs, and so on. Moreover, they mitigate the vanishing gradient problem even better than LSTMs. You've already seen how to combine attention with LSTMs to build **encoder-decoder models** for applications such as machine translation. \n\n<img src=\"attention_lnb_figs/C4_W2_L3_dot-product-attention_S01_introducing-attention_stripped.png\" width=\"500\"/>\n\nThis week, you'll see how to integrate attention into **transformers**. Because transformers are not sequence models, they are much easier to parallelize and accelerate. Beyond machine translation, applications of transformers include: \n* Auto-completion\n* Named Entity Recognition\n* Chatbots\n* Question-Answering\n* And more!\n\nAlong with embedding, positional encoding, dense layers, and residual connections, attention is a crucial component of transformers. At the heart of any attention scheme used in a transformer is **dot product attention**, of which the figures below display a simplified picture:\n\n<img src=\"attention_lnb_figs/C4_W2_L3_dot-product-attention_S03_concept-of-attention_stripped.png\" width=\"500\"/>\n\n<img src=\"attention_lnb_figs/C4_W2_L3_dot-product-attention_S04_attention-math_stripped.png\" width=\"500\"/>\n\nWith basic dot product attention, you capture the interactions between every word (embedding) in your query and every word in your key. If the queries and keys belong to the same sentences, this constitutes **bi-directional self-attention**. In some situations, however, it's more appropriate to consider only words which have come before the current one. Such cases, particularly when the queries and keys come from the same sentences, fall into the category of **causal attention**. \n\n<img src=\"attention_lnb_figs/C4_W2_L4_causal-attention_S02_causal-attention_stripped.png\" width=\"500\"/>\n\nFor causal attention, we add a **mask** to the argument of our softmax function, as illustrated below: \n\n<img src=\"attention_lnb_figs/C4_W2_L4_causal-attention_S03_causal-attention-math_stripped.png\" width=\"500\"/>\n\n<img src=\"attention_lnb_figs/C4_W2_L4_causal-attention_S04_causal-attention-math-2_stripped.png\" width=\"500\"/>\n\nNow let's see how to implement attention with NumPy. When you integrate attention into a transformer network defined with Trax, you'll have to use `trax.fastmath.numpy` instead, since Trax's arrays are based on JAX DeviceArrays. Fortunately, the function interfaces are often identical.\n\n\n## Imports\n\n::: {#fef157c7 .cell execution_count=1}\n``` {.python .cell-code}\nimport sys\n\nimport numpy as np\nimport scipy.special\n\nimport textwrap\nwrapper = textwrap.TextWrapper(width=70)\n\n# to print the entire np array\nnp.set_printoptions(threshold=sys.maxsize)\n```\n:::\n\n\nHere are some helper functions that will help you create tensors and display useful information:\n\n* `create_tensor()` creates a numpy array from a list of lists.\n* `display_tensor()` prints out the shape and the actual tensor.\n\n::: {#63a03784 .cell execution_count=2}\n``` {.python .cell-code}\ndef create_tensor(t):\n    \"\"\"Create tensor from list of lists\"\"\"\n    return np.array(t)\n\n\ndef display_tensor(t, name):\n    \"\"\"Display shape and tensor\"\"\"\n    print(f'{name} shape: {t.shape}\\n')\n    print(f'{t}\\n')\n```\n:::\n\n\nCreate some tensors and display their shapes. Feel free to experiment with your own tensors. Keep in mind, though, that the query, key, and value arrays must all have the same embedding dimensions (number of columns), and the mask array must have the same shape as `np.dot(query, key.T)`. \n\n::: {#8caa8c14 .cell execution_count=3}\n``` {.python .cell-code}\nq = create_tensor([[1, 0, 0], [0, 1, 0]])\ndisplay_tensor(q, 'query')\nk = create_tensor([[1, 2, 3], [4, 5, 6]])\ndisplay_tensor(k, 'key')\nv = create_tensor([[0, 1, 0], [1, 0, 1]])\ndisplay_tensor(v, 'value')\nm = create_tensor([[0, 0], [-1e9, 0]])\ndisplay_tensor(m, 'mask')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nquery shape: (2, 3)\n\n[[1 0 0]\n [0 1 0]]\n\nkey shape: (2, 3)\n\n[[1 2 3]\n [4 5 6]]\n\nvalue shape: (2, 3)\n\n[[0 1 0]\n [1 0 1]]\n\nmask shape: (2, 2)\n\n[[ 0.e+00  0.e+00]\n [-1.e+09  0.e+00]]\n\n```\n:::\n:::\n\n\n## Dot product attention\n\nHere we come to the crux of this lab, in which we compute \n$\\textrm{softmax} \\left(\\frac{Q K^T}{\\sqrt{d}} + M \\right) V$, where the (optional, but default) scaling factor $\\sqrt{d}$ is the square root of the embedding dimension.\n\n::: {#aa30f78d .cell execution_count=4}\n``` {.python .cell-code}\ndef DotProductAttention(query, key, value, mask, scale=True):\n    \"\"\"Dot product self-attention.\n    Args:\n        query (numpy.ndarray): array of query representations with shape (L_q by d)\n        key (numpy.ndarray): array of key representations with shape (L_k by d)\n        value (numpy.ndarray): array of value representations with shape (L_k by d) where L_v = L_k\n        mask (numpy.ndarray): attention-mask, gates attention with shape (L_q by L_k)\n        scale (bool): whether to scale the dot product of the query and transposed key\n\n    Returns:\n        numpy.ndarray: Self-attention array for q, k, v arrays. (L_q by L_k)\n    \"\"\"\n\n    assert query.shape[-1] == key.shape[-1] == value.shape[-1], \"Embedding dimensions of q, k, v aren't all the same\"\n\n    # Save depth/dimension of the query embedding for scaling down the dot product\n    if scale: \n        depth = query.shape[-1]\n    else:\n        depth = 1\n\n    # Calculate scaled query key dot product according to formula above\n    dots = np.matmul(query, np.swapaxes(key, -1, -2)) / np.sqrt(depth) \n    \n    # Apply the mask\n    if mask is not None:\n        dots = np.where(mask, dots, np.full_like(dots, -1e9)) \n    \n    # Softmax formula implementation\n    # Use scipy.special.logsumexp of masked_qkT to avoid underflow by division by large numbers\n    # Note: softmax = e^(dots - logaddexp(dots)) = E^dots / sumexp(dots)\n    logsumexp = scipy.special.logsumexp(dots, axis=-1, keepdims=True)\n\n    # Take exponential of dots minus logsumexp to get softmax\n    # Use np.exp()\n    dots = np.exp(dots - logsumexp)\n\n    # Multiply dots by value to get self-attention\n    # Use np.matmul()\n    attention = np.matmul(dots, value)\n    \n    return attention\n```\n:::\n\n\nNow let's implement the *masked* dot product self-attention (at the heart of causal attention) as a special case of dot product attention\n\n::: {#69c9cfa8 .cell execution_count=5}\n``` {.python .cell-code}\ndef dot_product_self_attention(q, k, v, scale=True):\n    \"\"\" Masked dot product self attention.\n    Args:\n        q (numpy.ndarray): queries.\n        k (numpy.ndarray): keys.\n        v (numpy.ndarray): values.\n    Returns:\n        numpy.ndarray: masked dot product self attention tensor.\n    \"\"\"\n    \n    # Size of the penultimate dimension of the query\n    mask_size = q.shape[-2]\n\n    # Creates a matrix with ones below the diagonal and 0s above. It should have shape (1, mask_size, mask_size)\n    # Use np.tril() - Lower triangle of an array and np.ones()\n    mask = np.tril(np.ones((1, mask_size, mask_size), dtype=np.bool_), k=0)  \n        \n    return DotProductAttention(q, k, v, mask, scale=scale)\n```\n:::\n\n\n::: {#c06a9eb4 .cell execution_count=6}\n``` {.python .cell-code}\ndot_product_self_attention(q, k, v)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\narray([[[0.        , 1.        , 0.        ],\n        [0.84967455, 0.15032545, 0.84967455]]])\n```\n:::\n:::\n\n\n",
    "supporting": [
      "lab01_files"
    ],
    "filters": [],
    "includes": {}
  }
}